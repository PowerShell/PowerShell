<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CannotDeserializeTabCompletionResult" xml:space="preserve">
    <value>The tab completion result cannot be properly deserialized because the remote runspace does not contain a TypeTable instance.</value>
  </data>
  <data name="NoAccessToProperties" xml:space="preserve">
    <value>Cannot access properties on a null instance of the type CompletionResult.</value>
  </data>
  <data name="bnotOperatorDescription" xml:space="preserve">
    <value>Bitwise NOT</value>
  </data>
  <data name="notOperatorDescription" xml:space="preserve">
    <value>Logical not. Negates the statement that follows it.</value>
  </data>
  <data name="eqOperatorDescription" xml:space="preserve">
    <value>Equal to - case insensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="ieqOperatorDescription" xml:space="preserve">
    <value>Equal to - case insensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="ceqOperatorDescription" xml:space="preserve">
    <value>Equal to - case sensitive. When the left operand is a collection, returns values from the collection that equal the right operand, otherwise returns TRUE if the left operand equals the right operand.</value>
  </data>
  <data name="neOperatorDescription" xml:space="preserve">
    <value>Not equal to - case insensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="ineOperatorDescription" xml:space="preserve">
    <value>Not equal to - case insensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="cneOperatorDescription" xml:space="preserve">
    <value>Not equal to - case sensitive. When the left operand is a collection, returns values from the collection that do not equal the right operand, otherwise returns TRUE if the left operand does not equal the right operand.</value>
  </data>
  <data name="geOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="igeOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="cgeOperatorDescription" xml:space="preserve">
    <value>Greater than or equal to - case sensitive. When the left operand is a collection, returns values from the collection that are greater than or equal to the right operand, otherwise returns TRUE if the left operand is greater than or equal to the right operand.</value>
  </data>
  <data name="gtOperatorDescription" xml:space="preserve">
    <value>Greater than - case insensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="igtOperatorDescription" xml:space="preserve">
    <value>Greater than - case insensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="cgtOperatorDescription" xml:space="preserve">
    <value>Greater than - case sensitive. When the left operand is a collection, returns values from the collection that are greater than the right operand, otherwise returns TRUE if the left operand is greater than the right operand.</value>
  </data>
  <data name="ltOperatorDescription" xml:space="preserve">
    <value>Less than - case insensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="iltOperatorDescription" xml:space="preserve">
    <value>Less than - case insensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="cltOperatorDescription" xml:space="preserve">
    <value>Less than - case sensitive. When the left operand is a collection, returns values from the collection that are less than the right operand, otherwise returns TRUE if the left operand is less than the right operand.</value>
  </data>
  <data name="leOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="ileOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case insensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="cleOperatorDescription" xml:space="preserve">
    <value>Less than or equal to - case sensitive. When the left operand is a collection, returns values from the collection that are less than or equal to the right operand, otherwise returns TRUE if the left operand is less than or equal to the right operand.</value>
  </data>
  <data name="likeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="ilikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="clikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case sensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="notlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="inotlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="cnotlikeOperatorDescription" xml:space="preserve">
    <value>Wildcard matching operator - case sensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="matchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="imatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="cmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case sensitive. When the left operand is a collection, returns values from the collection that match the right hand operand, otherwise returns TRUE if the left operand matches the right operand.</value>
  </data>
  <data name="notmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="inotmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case insensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="cnotmatchOperatorDescription" xml:space="preserve">
    <value>Regular expression matching operator - case sensitive. When the left operand is a collection, returns values from the collection that do not match the right hand operand, otherwise returns TRUE if the left operand does not match the right operand.</value>
  </data>
  <data name="replaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case insensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="ireplaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case insensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="creplaceOperatorDescription" xml:space="preserve">
    <value>Replace operator - case sensitive. Changes the left operand. Example: (dir *.ps1).FullName -replace '.ps1$','.ps1.bak'</value>
  </data>
  <data name="containsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="icontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="ccontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE only when the test value (right operand) exactly matches at least one of the values in the left operand.</value>
  </data>
  <data name="notcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="inotcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="cnotcontainsOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (right operand) exactly matches none of the values in the left operand.</value>
  </data>
  <data name="inOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="iinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="cinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches at least one of the values in the right operand.</value>
  </data>
  <data name="notinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="inotinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case insensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="cnotinOperatorDescription" xml:space="preserve">
    <value>Containment operator - case sensitive. Returns TRUE when the test value (left operand) exactly matches none of the values in the right operand.</value>
  </data>
  <data name="splitOperatorDescription" xml:space="preserve">
    <value>Split - case insensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="isplitOperatorDescription" xml:space="preserve">
    <value>Split - case insensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="csplitOperatorDescription" xml:space="preserve">
    <value>Split - case sensitive. Split one or more strings into substrings.
-Split &lt;String&gt;

&lt;String&gt; -Split &lt;Delimiter&gt;[,&lt;Max-substrings&gt;[,"&lt;Options&gt;"]]

&lt;String&gt; -Split {&lt;ScriptBlock&gt;} [,&lt;Max-substrings&gt;]</value>
  </data>
  <data name="isnotOperatorDescription" xml:space="preserve">
    <value>Returns TRUE when the left operand is not an instance of the specified .NET Framework type (right operand).</value>
  </data>
  <data name="isOperatorDescription" xml:space="preserve">
    <value>Returns TRUE when the left operand is an instance of the specified .NET Framework type (right operand).</value>
  </data>
  <data name="asOperatorDescription" xml:space="preserve">
    <value>Converts the left operand to the specified .NET Framework type (right operand).</value>
  </data>
  <data name="fOperatorDescription" xml:space="preserve">
    <value>Formats strings by using the format method of string objects.</value>
  </data>
  <data name="andOperatorDescription" xml:space="preserve">
    <value>Logical and. Returns TRUE when both statements are TRUE.</value>
  </data>
  <data name="bandOperatorDescription" xml:space="preserve">
    <value>Bitwise AND</value>
  </data>
  <data name="orOperatorDescription" xml:space="preserve">
    <value>Logical or. TRUE when either or both statements are TRUE.</value>
  </data>
  <data name="borOperatorDescription" xml:space="preserve">
    <value>Bitwise OR (inclusive)</value>
  </data>
  <data name="xorOperatorDescription" xml:space="preserve">
    <value>Logical exclusive or. Returns TRUE when one of the statements is TRUE and the other is FALSE.</value>
  </data>
  <data name="bxorOperatorDescription" xml:space="preserve">
    <value>Bitwise OR (exclusive)</value>
  </data>
  <data name="joinOperatorDescription" xml:space="preserve">
    <value>Join - combine multiple strings into a single string.
-Join &lt;String[]&gt;
&lt;String[]&gt; -Join &lt;Delimiter&gt;</value>
  </data>
  <data name="shlOperatorDescription" xml:space="preserve">
    <value>Shift Left bit operator. Inserts zero in right-most bit position.</value>
  </data>
  <data name="shrOperatorDescription" xml:space="preserve">
    <value>Shift Right bit operator. Inserts zero in the left-most bit position. For signed values, sign bit is preserved.</value>
  </data>
  <data name="NameHashtableKeyDescription" xml:space="preserve">
    <value>[string]
Specifies the name of the property being created.</value>
  </data>
  <data name="LabelHashtableKeyDescription" xml:space="preserve">
    <value>[string]
Specifies the name of the property being created.</value>
  </data>
  <data name="ExpressionHashtableKeyDescription" xml:space="preserve">
    <value>[scriptblock]
A script block used to calculate the value of the new property.</value>
  </data>
  <data name="AlignmentHashtableKeyDescription" xml:space="preserve">
    <value>[string]
Define how the values are displayed in a column.
Valid values are 'left', 'center', or 'right'.</value>
  </data>
  <data name="FormatStringHashtableKeyDescription" xml:space="preserve">
    <value>[string]
Specifies a format string that defines how the value is formatted for output.</value>
  </data>
  <data name="WidthHashtableKeyDescription" xml:space="preserve">
    <value>[int]
Specifies the maximum column width in a table when the value is displayed.
The value must be greater than 0.</value>
  </data>
  <data name="DepthHashtableKeyDescription" xml:space="preserve">
    <value>[int]
The depth key specifies the depth of expansion per property.</value>
  </data>
  <data name="AscendingHashtableKeyDescription" xml:space="preserve">
    <value>[bool]
Specifies the order of sorting for one or more properties.</value>
  </data>
  <data name="DescendingHashtableKeyDescription" xml:space="preserve">
    <value>[bool]
Specifies the order of sorting for one or more properties.</value>
  </data>
  <data name="LogNameHashtableKeyDescription" xml:space="preserve">
    <value>[String[]]
Specifies the log names to get events from.
Supports wildcards.</value>
  </data>
  <data name="ProviderNameHashtableKeyDescription" xml:space="preserve">
    <value>[String[]]
Specifies the event log providers to get events from.
Supports wildcards.</value>
  </data>
  <data name="PathHashtableKeyDescription" xml:space="preserve">
    <value>[String[]]
Specifies file paths to log files to get events from.
Valid file formats are: .etl, .evt, and .evtx</value>
  </data>
  <data name="KeywordsHashtableKeyDescription" xml:space="preserve">
    <value>[Long[]]
Selects events with the specified keyword bitmasks.
The following are standard keywords:
4503599627370496: AuditFailure
9007199254740992: AuditSuccess
4503599627370496: CorrelationHint
18014398509481984: CorrelationHint2
36028797018963968: EventLogClassic
281474976710656: ResponseTime
2251799813685248: Sqm
562949953421312: WdiContext
1125899906842624: WdiDiagnostic</value>
  </data>
  <data name="IDHashtableKeyDescription" xml:space="preserve">
    <value>[int[]]
Selects events with the specified event IDs.</value>
  </data>
  <data name="LevelHashtableKeyDescription" xml:space="preserve">
    <value>[int[]]
Selects events with the specified log levels.
The following log levels are valid:
1: Critical
2: Error
3: Warning
4: Informational
5: Verbose</value>
  </data>
  <data name="StartTimeHashtableKeyDescription" xml:space="preserve">
    <value>[datetime]
Selects events created after the specified date and time.</value>
  </data>
  <data name="EndTimeHashtableKeyDescription" xml:space="preserve">
    <value>[datetime]
Selects events created before the specified date and time.</value>
  </data>
  <data name="UserIDHashtableKeyDescription" xml:space="preserve">
    <value>[string]
Selects events generated by the specified user.
This can either be a string representation of a SID or a domain and username in the format DOMAIN\USERNAME or USERNAME@DOMAIN</value>
  </data>
  <data name="DataHashtableKeyDescription" xml:space="preserve">
    <value>[string[]]
Selects events with any of the specified values in the EventData section.</value>
  </data>  
  <data name="SuppressHashFilterHashtableKeyDescription" xml:space="preserve">
    <value>[hashtable]
Excludes events that match the values specified in the hashtable.</value>
  </data>
  <data name="RequiresModulesParameterDescription" xml:space="preserve">
    <value>[string] or [hashtable]
Specifies an array of PowerShell modules that the script requires.
Each element can either be a string with the module name as value or a hashtable with the following keys:
Name: Name of the module
GUID: GUID of the module
One of the following:
ModuleVersion: Specifies a minimum acceptable version of the module.
RequiredVersion: Specifies an exact, required version of the module.
MaximumVersion: Specifies the maximum acceptable version of the module.</value>
  </data>
  <data name="RequiresPSEditionParameterDescription" xml:space="preserve">
    <value>[string]
Specifies a PowerShell edition that the script requires.
Valid values are "Core" and "Desktop"</value>
  </data>
  <data name="RequiresRunAsAdministratorParameterDescription" xml:space="preserve">
    <value>[switch]
Specifies that PowerShell must be running as administrator on Windows.
This must be the last parameter on the #requires statement line.</value>
  </data>
  <data name="RequiresVersionParameterDescription" xml:space="preserve">
    <value>[version]
Specifies the minimum version of PowerShell that the script requires.</value>
  </data>
  <data name="RequiresPsEditionCoreDescription" xml:space="preserve">
    <value>Specifies that the script requires PowerShell Core to run.</value>
  </data>
  <data name="RequiresPsEditionDesktopDescription" xml:space="preserve">
    <value>Specifies that the script requires Windows PowerShell to run.</value>
  </data>
  <data name="RequiresModuleSpecModuleNameDescription" xml:space="preserve">
    <value>[string]
Required. Specifies the module name.</value>
  </data>
  <data name="RequiresModuleSpecGUIDDescription" xml:space="preserve">
    <value>[string]
Optional. Specifies the GUID of the module.</value>
  </data>
  <data name="RequiresModuleSpecModuleVersionDescription" xml:space="preserve">
    <value>[string]
Specifies a minimum acceptable version of the module.</value>
  </data>
  <data name="RequiresModuleSpecRequiredVersionDescription" xml:space="preserve">
    <value>[string]
Specifies an exact, required version of the module.</value>
  </data>
  <data name="RequiresModuleSpecMaximumVersionDescription" xml:space="preserve">
    <value>[string]
Specifies the maximum acceptable version of the module.</value>
  </data>
  <data name="CommentHelpSYNOPSISKeywordDescription" xml:space="preserve">
    <value>A brief description of the function or script.
This keyword can be used only once in each topic.</value>
  </data>
  <data name="CommentHelpDESCRIPTIONKeywordDescription" xml:space="preserve">
    <value>A detailed description of the function or script.
This keyword can be used only once in each topic.</value>
  </data>
  <data name="CommentHelpPARAMETERKeywordDescription" xml:space="preserve">
    <value>.PARAMETER  &lt;Parameter-Name&gt;
The description of a parameter.
Add a .PARAMETER keyword for each parameter in the function or script syntax.</value>
  </data>
  <data name="CommentHelpEXAMPLEKeywordDescription" xml:space="preserve">
    <value>A sample command that uses the function or script, optionally followed by sample output and a description.
Repeat this keyword for each example.</value>
  </data>
  <data name="CommentHelpINPUTSKeywordDescription" xml:space="preserve">
    <value>The .NET types of objects that can be piped to the function or script.
You can also include a description of the input objects.</value>
  </data>
  <data name="CommentHelpOUTPUTSKeywordDescription" xml:space="preserve">
    <value>The .NET type of the objects that the cmdlet returns.
You can also include a description of the returned objects.</value>
  </data>
  <data name="CommentHelpNOTESKeywordDescription" xml:space="preserve">
    <value>Additional information about the function or script.</value>
  </data>
  <data name="CommentHelpLINKKeywordDescription" xml:space="preserve">
    <value>The name of a related topic.
Repeat the .LINK keyword for each related topic.
The .Link keyword content can also include a URI to an online version of the same help topic.</value>
  </data>
  <data name="CommentHelpCOMPONENTKeywordDescription" xml:space="preserve">
    <value>The name of the technology or feature that the function or script uses, or to which it is related.</value>
  </data>
  <data name="CommentHelpROLEKeywordDescription" xml:space="preserve">
    <value>The name of the user role for the help topic.</value>
  </data>
  <data name="CommentHelpFUNCTIONALITYKeywordDescription" xml:space="preserve">
    <value>The keywords that describe the intended use of the function.</value>
  </data>
  <data name="CommentHelpFORWARDHELPTARGETNAMEKeywordDescription" xml:space="preserve">
    <value>.FORWARDHELPTARGETNAME &lt;Command-Name&gt;
Redirects to the help topic for the specified command.</value>
  </data>
  <data name="CommentHelpFORWARDHELPCATEGORYKeywordDescription" xml:space="preserve">
    <value>.FORWARDHELPCATEGORY &lt;Category&gt;
Specifies the help category of the item in .ForwardHelpTargetName</value>
  </data>
  <data name="CommentHelpREMOTEHELPRUNSPACEKeywordDescription" xml:space="preserve">
    <value>.REMOTEHELPRUNSPACE &lt;PSSession-variable&gt;
Specifies a session that contains the help topic.
Enter a variable that contains a PSSession object.</value>
  </data>
  <data name="CommentHelpEXTERNALHELPKeywordDescription" xml:space="preserve">
    <value>.EXTERNALHELP &lt;XML Help File&gt;
The .ExternalHelp keyword is required when a function or script is documented in XML files.</value>
  </data>
  <data name="AssemblyKeywordDescription" xml:space="preserve">
    <value>Specifies the path to a .NET assembly to load.

using assembly &lt;.NET-assembly-path&gt;</value>
  </data>
  <data name="ModuleKeywordDescription" xml:space="preserve">
    <value>Specifies a PowerShell module to load classes from.

using module &lt;ModuleName or Path&gt;

using module &lt;ModuleSpecification hashtable&gt;</value>
  </data>
  <data name="NamespaceKeywordDescription" xml:space="preserve">
    <value>Specifies a .NET namespace to resolve types from or a namespace alias.

using namespace &lt;.NET-namespace&gt;

using namespace &lt;AliasName&gt; = &lt;.NET-namespace&gt;</value>
  </data>
  <data name="TypeKeywordDescription" xml:space="preserve">
    <value>Specifies an alias for a .NET Type.

using type &lt;AliasName&gt; = &lt;.NET-type&gt;</value>
  </data>
  <data name="beginKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed at the beginning of a script/function, before any process block in the pipeline has been run.

begin {}</value>
  </data>
  <data name="breakKeywordDescription" xml:space="preserve">
    <value>Exits the current loop. If a label is specified, each encompassing loop will be exited until the label is reached.
When used in a trap, it displays the trapped error and aborts execution of the script/function.

break &lt;Optional Label Name&gt;</value>
  </data>
  <data name="catchKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed when a terminating error is caught in a previously defined Try block.
Zero or more exceptions can be specified to catch specific errors.

catch &lt;[Optional Exception 1]&gt;, &lt;[Optional Exception 2]&gt; {}</value>
  </data>
  <data name="classKeywordDescription" xml:space="preserve">
    <value>Specifies a PowerShell class definition. A base class or one or more interfaces can optionally be specified.

class &lt;[ClassName]&gt; : &lt;[BaseClass1 or Interface1]&gt;, &lt;[Interface2]&gt; {}</value>
</data>
  <data name="cleanKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is run after a script/function is executed. This block is always run, regardless of any terminating errors.

clean {}</value>
  </data>
  <data name="continueKeywordDescription" xml:space="preserve">
    <value>Advances the loop immediately, skipping over the remaining statements. If a label is specified, each encompassing loop will be exited until the label is reached.
When used in a trap, it silences the trapped error and continues execution of the script/function.

continue &lt;Optional Label Name&gt;</value>
  </data>
  <data name="dataKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is restricted to a specified subset of the PowerShell language.
A variable and a list of supported commands can optionally be specified.

data &lt;VariableName&gt; -supportedCommand &lt;Command1&gt;, &lt;Command2&gt; {}</value>
  </data>
  <data name="doKeywordDescription" xml:space="preserve">
    <value>Defines a loop that is executed one or more times, until the specified condition is met.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

do {} while (&lt;Condition&gt;)
do {} until (&lt;Condition&gt;)
:label do {} while (&lt;Condition&gt;)
:label do {} until (&lt;Condition&gt;)</value>
  </data>
  <data name="dynamicparamKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed when tab completing parameters and when the command is executed to create dynamic parameters.

dynamicparam {}</value>
  </data>
  <data name="elseKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is executed if all previous if/elseif statements evaluate to false.

else {}</value>
  </data>
  <data name="elseifKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is executed if all previous if/elseif statements evaluate to false and the specified condition evaluates to true.

elseif (&lt;Condition&gt;) {}</value>
  </data>
  <data name="endKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed after the containing script/function has run its begin and process blocks.
The End block is executed after the Process block has finished processing all incoming pipeline input.

end {}</value>
  </data>
  <data name="enumKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell type definition for an Enum.

enum &lt;TypeName&gt; {}</value>
  </data>
  <data name="exitKeywordDescription" xml:space="preserve">
    <value>When used inside a script, stops the rest of the script from being executed.
When used interactively, exits the nested prompt (debugger, remote connection), when used at the top level it exits the shell itself.
An exit code can optionally be provided to inform the parent process about the script status.

exit &lt;ExitCode&gt;</value>
  </data>
  <data name="filterKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell function where the default block is a Process block rather than an End block.

filter &lt;FilterName&gt; {param()}
filter &lt;FilterName&gt; {param() dynamicparam {} begin {} process {} end {} clean {}}</value>
  </data>
  <data name="finallyKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is always executed after the try block, regardless of any terminating errors.

finally {}</value>
  </data>
  <data name="forKeywordDescription" xml:space="preserve">
    <value>Defines a for loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

for (&lt;Initializer&gt;;&lt;Condition&gt;;&lt;AdvanceAction&gt;;) {}
:label for (&lt;Initializer&gt;;&lt;Condition&gt;;&lt;AdvanceAction&gt;;) {}</value>
  </data>
  <data name="foreachKeywordDescription" xml:space="preserve">
    <value>Defines a foreach loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}
:label foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}</value>
  </data>
  <data name="functionKeywordDescription" xml:space="preserve">
    <value>Defines a PowerShell function.

function &lt;FunctionName&gt; {param()}
function &lt;FunctionName&gt; {param() dynamicparam {} begin {} process {} end {} clean {}}</value>
  </data>
  <data name="hiddenKeywordDescription" xml:space="preserve">
    <value>Hides the specified class member from tab completion and Get-Member.

hidden &lt;MemberName&gt;</value>
  </data>
  <data name="ifKeywordDescription" xml:space="preserve">
    <value>Defines a statement block that is only executed if the specified condition evaluates to true.

if (&lt;Condition&gt;) {}</value>
  </data>
  <data name="inKeywordDescription" xml:space="preserve">
    <value>Required keyword in foreach loop definition.

foreach (&lt;CurrentItemVariable&gt; in &lt;Collection&gt;) {}</value>
  </data>
  <data name="paramKeywordDescription" xml:space="preserve">
    <value>Specifies the parameters for a scriptblock.

param()</value>
  </data>
  <data name="processKeywordDescription" xml:space="preserve">
    <value>Specifies a scriptblock that is executed once for each item received from the pipeline.

process {}</value>
  </data>
  <data name="returnKeywordDescription" xml:space="preserve">
    <value>Stops execution of code in the current scriptblock and optionally returns the specified value.
In class methods that return something, all code paths need to lead to a return statement.

return &lt;Optional Value To Return&gt;</value>
  </data>
  <data name="staticKeywordDescription" xml:space="preserve">
    <value>Defines the following class member as a static member.

static &lt;MemberName&gt;</value>
  </data>
  <data name="switchKeywordDescription" xml:space="preserve">
    <value>Defines a loop that evaluates the specified conditions for each item.
Various parameters for the Switch can optionally be set.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

switch (&lt;Collection&gt;) {}
switch -OptionalParameters (&lt;Collection&gt;) {}
:label switch -OptionalParameters (&lt;Collection&gt;) {}</value>
  </data>
  <data name="throwKeywordDescription" xml:space="preserve">
    <value>Throws a terminating error, optionally with a string, ErrorRecord or Exception that describes the error.

throw &lt;Optional Expression&gt;</value>
  </data>
  <data name="trapKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed when an unhandled exception is thrown in the script/function.

trap {}</value>
  </data>
  <data name="tryKeywordDescription" xml:space="preserve">
    <value>Defines a scriptblock that is executed.
If a terminating error is thrown from the scriptblock the execution is stopped at the failing statement and the configured catch or finally scriptblocks are executed.

try {}</value>
  </data>
  <data name="untilKeywordDescription" xml:space="preserve">
    <value>Defines a condition for a Do loop, if the condition is evaluated to true, the loop exits.

do {} until (&lt;Condition&gt;)</value>
  </data>
  <data name="usingKeywordDescription" xml:space="preserve">
    <value>Defines an assembly, module, namespace, or namespace/type alias to load.

using assembly
using module
using namespace
using type</value>
  </data>
  <data name="whileKeywordDescription" xml:space="preserve">
    <value>Defines either a While loop, or a condition for a Do loop.
A label can optionally be set, allowing you to use continue and break statements from nested loops.

while (&lt;Condition&gt;) {}
:label while (&lt;Condition&gt;) {}
do {} while (&lt;Condition&gt;)</value>
  </data>
  <data name="RegistryStringToolTip" xml:space="preserve">
    <value>A normal string.</value>
  </data>
  <data name="RegistryExpandStringToolTip" xml:space="preserve">
    <value>A string that contains unexpanded references to environment variables that are expanded when the value is retrieved.</value>
  </data>
  <data name="RegistryBinaryToolTip" xml:space="preserve">
    <value>Binary data in any form.</value>
  </data>
  <data name="RegistryDWordToolTip" xml:space="preserve">
    <value>A 32-bit binary number.</value>
  </data>
  <data name="RegistryMultiStringToolTip" xml:space="preserve">
    <value>An array of strings.</value>
  </data>
  <data name="RegistryQWordToolTip" xml:space="preserve">
    <value>A 64-bit binary number.</value>
  </data>
  <data name="RegistryUnknownToolTip" xml:space="preserve">
    <value>An unsupported registry data type.</value>
  </data>
  <data name="SeparatorCommaToolTip" xml:space="preserve">
    <value>',' - Comma</value>
  </data>
  <data name="SeparatorCommaSpaceToolTip" xml:space="preserve">
    <value>', ' - Comma-Space</value>
  </data>
  <data name="SeparatorSemiColonToolTip" xml:space="preserve">
    <value>';' - Semi-Colon</value>
  </data>
  <data name="SeparatorSemiColonSpaceToolTip" xml:space="preserve">
    <value>'; ' - Semi-Colon-Space</value>
  </data>
  <data name="SeparatorNewlineToolTip" xml:space="preserve">
    <value>{0} - Newline</value>
  </data>
  <data name="SeparatorDashToolTip" xml:space="preserve">
    <value>'-' - Dash</value>
  </data>
  <data name="SeparatorSpaceToolTip" xml:space="preserve">
    <value>' ' - Space</value>
  </data>
</root>
