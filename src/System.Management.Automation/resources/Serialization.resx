<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AttributeExpected" xml:space="preserve">
    <value>{0} attribute was expected.</value>
  </data>
  <data name="InvalidElementTag" xml:space="preserve">
    <value>{0} XML tag is not recognized.</value>
  </data>
  <data name="InvalidReferenceId" xml:space="preserve">
    <value>No object found for referenceId {0}</value>
  </data>
  <data name="InvalidDictionaryKeyName" xml:space="preserve">
    <value>Name attribute for dictionary key is incorrectly specified.</value>
  </data>
  <data name="InvalidDictionaryValueName" xml:space="preserve">
    <value>Name attribute for dictionary value is incorrectly specified.</value>
  </data>
  <data name="InvalidVersion" xml:space="preserve">
    <value>Version of PSObject is not valid.</value>
  </data>
  <data name="UnexpectedVersion" xml:space="preserve">
    <value>Version of incoming PSObject is {0}. Expected value is 1.</value>
  </data>
  <data name="InvalidTypeHierarchyReferenceId" xml:space="preserve">
    <value>Cannot process names because no TypeNames were found for referenceId {0}.</value>
  </data>
  <data name="DepthOfOneRequired" xml:space="preserve">
    <value>Value of depth parameter must be greater than or equal to 1.</value>
  </data>
  <data name="InvalidNodeType" xml:space="preserve">
    <value>Current Node type is {0}. Expected type is {1}.</value>
  </data>
  <data name="DictionaryKeyNotSpecified" xml:space="preserve">
    <value>Key for dictionary entry is not specified.</value>
  </data>
  <data name="DictionaryValueNotSpecified" xml:space="preserve">
    <value>Value for dictionary entry is not specified.</value>
  </data>
  <data name="ReadCalledAfterDone" xml:space="preserve">
    <value>There are no more objects to deserialize.</value>
  </data>
  <data name="NullAsDictionaryKey" xml:space="preserve">
    <value>Null is specified as dictionary key.</value>
  </data>
  <data name="InvalidPrimitiveType" xml:space="preserve">
    <value>The contents of the {0} primitive type are not valid.</value>
  </data>
  <data name="DeserializationTooDeep" xml:space="preserve">
    <value>Serialized XML is nested too deeply.</value>
  </data>
  <data name="Stopping" xml:space="preserve">
    <value>Serializer was closed.</value>
  </data>
  <data name="DeserializationMemoryQuota" xml:space="preserve">
    <value>The data in the command exceeded the maximum size that is allowed by the session configuration. The allowed maximum is {0} MB. Change the input, use a different session configuration, or change the "{1}" and "{2}" properties of the session configuration on the remote computer.</value>
  </data>
  <data name="DeserializeSecureStringFailed" xml:space="preserve">
    <value>Deserialization of encrypted secure string failed</value>
  </data>
  <data name="PrimitiveHashtableInvalidKey" xml:space="preserve">
    <value>The key type {0} is not valid. The PSPrimitiveDictionary class accepts only keys of the type System.String.</value>
  </data>
  <data name="PrimitiveHashtableInvalidValue" xml:space="preserve">
    <value>The type of the value {0} is not valid. The PSPrimitiveDictionary class accepts only values of types that are fully serializable over PowerShell remoting. See the Help topic about_Remoting for a list of fully-serializable types.</value>
  </data>
  <data name="InvalidKey" xml:space="preserve">
    <value>Could not decrypt data. The data was not encrypted with this key.</value>
  </data>
  <data name="InvalidEncryptedString" xml:space="preserve">
    <value>The parameter value "{0}" is not a valid encrypted string.</value>
  </data>
  <data name="InvalidKeyLength" xml:space="preserve">
    <value>The specified {0} is not valid. Valid {0} length settings are either 128 bits, 192 bits, or 256 bits.</value>
  </data>
  <data name="DeserializeSecureStringNotSupported" xml:space="preserve">
    <value>Deserialization of SecureString is currently only supported on Windows.</value>
  </data>
</root>
