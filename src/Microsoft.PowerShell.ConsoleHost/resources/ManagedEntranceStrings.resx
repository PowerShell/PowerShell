<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ShellBannerNonWindowsPowerShell" xml:space="preserve">
    <value>PowerShell {0}</value>
  </data>
  <data name="ShellBannerCLMode" xml:space="preserve">
    <value>[Constrained Language Mode]</value>
  </data>
  <data name="ShellBannerCLAuditMode" xml:space="preserve">
    <value>[Constrained Language AUDIT Mode : No Restrictions]</value>
  </data>
  <data name="ShellBannerNLMode" xml:space="preserve">
    <value>[No Language Mode]</value>
  </data>
  <data name="ShellBannerRLMode" xml:space="preserve">
    <value>[Restricted Language Mode]</value>
  </data>
  <data name="PSReadLineDisabledWhenScreenReaderIsActive" xml:space="preserve">
    <value>Warning: PowerShell detected that you might be using a screen reader and has disabled PSReadLine for compatibility purposes. If you want to re-enable it, run 'Import-Module PSReadLine'.</value>
  </data>
  <data name="PreviewUpdateNotificationMessage" xml:space="preserve">
    <value>  {1} A new PowerShell preview release is available: v{0} {2}
  {1} Upgrade now, or check out the release page at:{3}{2}
  {1}   https://aka.ms/PowerShell-Release?tag=v{0} {4}{2}
</value>
  </data>
  <data name="StableUpdateNotificationMessage" xml:space="preserve">
    <value>  {1} A new PowerShell stable release is available: v{0} {2}
  {1} Upgrade now, or check out the release page at:{3}{2}
  {1}   https://aka.ms/PowerShell-Release?tag=v{0} {4}{2}
</value>
  </data>
  <data name="LTSUpdateNotificationMessage" xml:space="preserve">
    <value>  {1} A new PowerShell LTS release is available: v{0} {2}
  {1} Upgrade now, or check out the release page at:{3}{2}
  {1}   https://aka.ms/PowerShell-Release?tag=v{0} {4}{2}
</value>
  </data>
  <data name="UsageHelp" xml:space="preserve">
    <value>Usage: pwsh[.exe] [-Login] [[-File] &lt;filePath&gt; [args]]
                  [-Command { - | &lt;script-block&gt; [-args &lt;arg-array&gt;]
                                | &lt;string&gt; [&lt;CommandParameters&gt;] } ]
                  [-CommandWithArgs &lt;string&gt; [&lt;CommandParameters&gt;]
                  [-ConfigurationName &lt;string&gt;] [-ConfigurationFile &lt;filePath&gt;]
                  [-CustomPipeName &lt;string&gt;] [-EncodedCommand &lt;Base64EncodedCommand&gt;]
                  [-ExecutionPolicy &lt;ExecutionPolicy&gt;] [-InputFormat {Text | XML}]
                  [-Interactive] [-MTA] [-NoExit] [-NoLogo] [-NonInteractive] [-NoProfile]
                  [-NoProfileLoadTime] [-OutputFormat {Text | XML}] 
                  [-SettingsFile &lt;filePath&gt;] [-SSHServerMode] [-STA] 
                  [-Version] [-WindowStyle &lt;style&gt;] 
                  [-WorkingDirectory &lt;directoryPath&gt;]

       pwsh[.exe] -h | -Help | -? | /?

PowerShell Online Help https://aka.ms/powershell-docs

All parameters are case-insensitive.</value>
  </data>
  <data name="ExtendedHelp" xml:space="preserve">
    <value>

-File | -f

    If the value of File is "-", the command text is read from standard input.
    Running "pwsh -File -" without redirected standard input starts a regular
    session. This is the same as not specifying the File parameter at all.

    This is the default parameter if no parameters are present but values are
    present in the command line. The specified script runs in the local scope
    ("dot-sourced"), so that the functions and variables that the script
    creates are available in the current session. Enter the script file path
    and any parameters. File must be the last parameter in the command, because
    all characters typed after the File parameter name are interpreted as the
    script file path followed by the script parameters.

    Typically, the switch parameters of a script are either included or
    omitted. For example, the following command uses the All parameter of the
    Get-Script.ps1 script file: "-File .\Get-Script.ps1 -All"

    In rare cases, you might need to provide a BOOLEAN value for a switch
    parameter. To provide a BOOLEAN value for a switch parameter in the value
    of the FILE parameter, Use the parameter normally followed immediately by a
    colon and the boolean value, such as the following:
    "-File .\Get-Script.ps1 -All:$False".

    Parameters passed to the script are passed as literal strings, after
    interpretation by the current shell. For example, if you are in cmd.exe and
    want to pass an environment variable value, you would use the cmd.exe
    syntax: "pwsh -File .\test.ps1 -TestParam %windir%"

    In contrast, running "pwsh -File .\test.ps1 -TestParam $env:windir" in
    cmd.exe results in the script receiving the literal string "$env:windir"
    because it has no special meaning to the current cmd.exe shell. The
    "$env:windir" style of environment variable reference can be used inside a
    Command parameter, since there it is interpreted as PowerShell code.

    Similarly, if you want to execute the same command from a Batch script,
    you would use "%~dp0" instead of ".\" or "$PSScriptRoot" to represent the current
    execution directory: "pwsh -File %~dp0test.ps1 -TestParam %windir%". If you
    instead used ".\test.ps1", PowerShell would throw an error because it cannot
    find the literal path ".\test.ps1".

    When the script file invoked terminates with an exit command, the process
    exit code is set to the numeric argument used with the exit command. With
    normal termination, the exit code is always 0.

    Similar to -Command, when a script-terminating error occurs, the exit code
    is set to 1. However, unlike with -Command, when the execution is
    interrupted with Ctrl-C the exit code is 0.

-Command | -c

    Executes the specified commands (and any parameters) as though they were
    typed at the PowerShell command prompt, and then exits, unless the NoExit
    parameter is specified.

    The value of Command can be "-", a script block, or a string. If the value
    of Command is "-", the command text is read from standard input.

    The Command parameter only accepts a script block for execution when it can
    recognize the value passed to Command as a ScriptBlock type. This is only
    possible when running pwsh from another PowerShell host. The ScriptBlock
    type may be contained in an existing variable, returned from an expression,
    or parsed by the PowerShell host as a literal script block enclosed in
    curly braces "{}", before being passed to pwsh.

        pwsh -Command {Get-WinEvent -LogName security}

    In cmd.exe, there is no such thing as a script block (or ScriptBlock type),
    so the value passed to Command will always be a string. You can write a
    script block inside the string, but instead of being executed it will
    behave exactly as though you typed it at a typical PowerShell prompt,
    printing the contents of the script block back out to you.

    A string passed to Command is still executed as PowerShell script, so the
    script block curly braces are often not required in the first place when
    running from cmd.exe. To execute an inline script block defined inside a
    string, the call operator "&amp;" can be used:

        pwsh -Command "&amp; {Get-WinEvent -LogName security}"

    If the value of Command is a string, Command must be the last parameter for
    pwsh, because all arguments following it are interpreted as part of the
    command to execute.

    When called from within an existing PowerShell session, the results are
    returned to the parent shell as deserialized XML objects, not live objects.
    For other shells, the results are returned as strings.

    If the value of Command is "-", the command text is read from standard
    input. You must redirect standard input when using the Command parameter
    with standard input. For example:

        @'
        "in"

        "hi" |
        % { "$_ there" }

        "out"
        '@ | powershell -NoProfile -Command -

    This example produces the following output:

        in
        hi there
        out

    The process exit code is determined by status of the last (executed)
    command within the script block. The exit code is 0 when $? is $true or 1
    when $? is $false. If the last command is an external program or a
    PowerShell script that explicitly sets an exit code other than 0 or 1, that
    exit code is converted to 1 for process exit code. To preserve the specific
    exit code, add exit $LASTEXITCODE to your command string or script block.

    Similarly, the value 1 is returned when a script-terminating
    (runspace-terminating) error, such as a throw or -ErrorAction Stop, occurs
    or when execution is interrupted with Ctrl-C.

-CommandWithArgs | -cwa

    [Experimental]
    Executes a PowerShell command with arguments.  Unlike `-Command`, this
    parameter populates the `$args built-in variable which can be used by the
    command.

    The first string is the command and subsequent strings delimited by whitespace
    are the arguments.

    For example:

        pwsh -CommandWithArgs '$args | % { "arg: $_" }' arg1 arg2

    This example produces the following output:

        arg: arg1
        arg: arg2

-ConfigurationName | -config

    Specifies a configuration endpoint in which PowerShell is run. This can be
    any endpoint registered on the local machine including the default
    PowerShell remoting endpoints or a custom endpoint having specific user
    role capabilities.

    Example: "pwsh -ConfigurationName AdminRoles"

-ConfigurationFile

    Specifies a session configuration (.pssc) file path. The configuration
    contained in the configuration file will be applied to the PowerShell
    session.

    Example: "pwsh -ConfigurationFile "C:\ProgramData\PowerShell\MyConfig.pssc"

-CustomPipeName

    Specifies the name to use for an additional IPC server (named pipe) used
    for debugging and other cross-process communication. This offers a
    predictable mechanism for connecting to other PowerShell instances.
    Typically used with the CustomPipeName parameter on "Enter-PSHostProcess".

    This parameter was introduced in PowerShell 6.2.

    For example:

        # PowerShell instance 1
        pwsh -CustomPipeName mydebugpipe
        # PowerShell instance 2
        Enter-PSHostProcess -CustomPipeName mydebugpipe

-EncodedCommand | -e | -ec

    Accepts a Base64-encoded string version of a command. Use this parameter to
    submit commands to PowerShell that require complex, nested quoting. The
    Base64 representation must be a UTF-16 encoded string.

    For example:

        $command = 'dir "c:\program files" '
        $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
        $encodedCommand = [Convert]::ToBase64String($bytes)
        pwsh -encodedcommand $encodedCommand

-ExecutionPolicy | -ex | -ep

    Sets the default execution policy for the current session and saves it in
    the $env:PSExecutionPolicyPreference environment variable. This parameter
    does not change the persistently configured execution policies.

    This parameter only applies to Windows computers. The
    $env:PSExecutionPolicyPreference environment variable does not exist on
    non-Windows platforms.

-InputFormat | -inp | -if

    Describes the format of data sent to PowerShell. Valid values are "Text"
    (text strings) or "XML" (serialized CLIXML format).

-Interactive | -i

    Present an interactive prompt to the user. Inverse for NonInteractive
    parameter.

-Login | -l

    On Linux and macOS, starts PowerShell as a login shell, using /bin/sh to
    execute login profiles such as /etc/profile and ~/.profile. On Windows,
    this switch does nothing.

    [!IMPORTANT] This parameter must come first to start PowerShell as a login
    shell. The parameter is ignored if passed in any other position.

    To set up pwsh as the login shell on UNIX-like operating systems:

    - Verify that the full absolute path to pwsh is listed under /etc/shells

      - This path is usually something like /usr/bin/pwsh on Linux or
        /usr/local/bin/pwsh on macOS
      - With some installation methods, this entry will be added
        automatically at installation time
      - If pwsh is not present in /etc/shells, use an editor to append the
        path to pwsh on the last line. This requires elevated privileges to
        edit.

    - Use the chsh utility to set your current user's shell to pwsh:

        chsh -s /usr/bin/pwsh

    [!WARNING] Setting pwsh as the login shell is currently not supported on
    Windows Subsystem for Linux (WSL), and attempting to set pwsh as the
    login shell there may lead to being unable to start WSL interactively.

-MTA

    Start PowerShell using a multi-threaded apartment. This switch is only
    available on Windows.

-NoExit | -noe

    Does not exit after running startup commands.

    Example: "pwsh -NoExit -Command Get-Date"

-NoLogo | -nol

    Hides the banner text at startup of interactive sessions.

-NonInteractive | -noni

    This switch is used to create sessions that shouldn't require user input.
    This is useful for scripts that run in scheduled tasks or CI/CD pipelines.
    Any attempts to use interactive features, like 'Read-Host' or confirmation
    prompts, result in statement terminating errors rather than hanging.

-NoProfile | -nop

    Does not load the PowerShell profiles.

-NoProfileLoadTime

    Hides the PowerShell profile load time text shown at startup when the load
    time exceeds 500 milliseconds.

-OutputFormat | -o | -of

    Determines how output from PowerShell is formatted. Valid values are "Text"
    (text strings) or "XML" (serialized CLIXML format).

    Example: "pwsh -o XML -c Get-Date"

    When called within a PowerShell session, you get deserialized objects as
    output rather plain strings. When called from other shells, the output is
    string data formatted as CLIXML text.

-SettingsFile | -settings

    Overrides the system-wide "powershell.config.json" settings file for the
    session. By default, system-wide settings are read from the
    "powershell.config.json" in the "$PSHOME" directory.

    Note that these settings are not used by the endpoint specified by the
    "-ConfigurationName" argument.

    Example: "pwsh -SettingsFile c:\myproject\powershell.config.json"

-SSHServerMode | -sshs

    Used in sshd_config for running PowerShell as an SSH subsystem. It is not
    intended or supported for any other use.

-STA

    Start PowerShell using a single-threaded apartment. This is the default.
    This switch is only available on Windows.

-Version | -v

    Displays the version of PowerShell. Additional parameters are ignored.

-WindowStyle | -w

    Sets the window style for the session. Valid values are Normal, Minimized,
    Maximized and Hidden.

-WorkingDirectory | -wd

    Sets the initial working directory by executing at startup. Any valid
    PowerShell file path is supported.

    To start PowerShell in your home directory, use: pwsh -WorkingDirectory ~

-Help, -?, /?

    Displays help for pwsh. If you are typing a pwsh command in PowerShell,
    prepend the command parameters with a hyphen (-), not a forward slash (/).
    </value>
  </data>
</root>
