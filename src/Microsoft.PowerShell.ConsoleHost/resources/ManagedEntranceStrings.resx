<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ShellBannerNonWindowsPowerShell" xml:space="preserve">
    <value>PowerShell {0}
Copyright (c) Microsoft Corporation. All rights reserved.

https://aka.ms/pscore6-docs
Type 'help' to get help.</value>
  </data>
  <data name="UsageHelp" xml:space="preserve">
    <value>Usage: pwsh[.exe] [[-File] &lt;filePath&gt; [args]]
                  [-Command { - | &lt;script-block&gt; [-args &lt;arg-array&gt;]
                                | &lt;string&gt; [&lt;CommandParameters&gt;] } ]
                  [-ConfigurationName &lt;string&gt;] [-CustomPipeName &lt;string&gt;]
                  [-EncodedCommand &lt;Base64EncodedCommand&gt;]
                  [-ExecutionPolicy &lt;ExecutionPolicy&gt;] [-InputFormat {Text | XML}]
                  [-Interactive] [-NoExit] [-NoLogo] [-NonInteractive] [-NoProfile]
                  [-OutputFormat {Text | XML}] [-Version] [-WindowStyle &lt;style&gt;]
                  [-WorkingDirectory &lt;directoryPath&gt;]

       pwsh[.exe] -h | -Help | -? | /?

PowerShell Online Help https://aka.ms/pscore6-docs

All parameters are case-insensitive.</value>
  </data>
  <data name="ExtendedHelp" xml:space="preserve">
    <value>

-Command | -c
    Executes the specified commands (and any parameters) as though they were typed
    at the PowerShell command prompt, and then exits, unless NoExit is specified.
    The value of Command can be "-", a string. or a script block.

    If the value of Command is "-", the command text is read from standard input.

    If the value of Command is a script block, the script block must be enclosed
    in braces ({}). You can specify a script block only when running 'pwsh'
    in a PowerShell session. The results of the script block are returned to the
    parent shell as deserialized XML objects, not live objects.

    If the value of Command is a string, Command must be the last parameter in the command,
    because any characters typed after the command are interpreted as the command arguments.

    To write a string that runs a PowerShell command, use the format:
    "&amp; {&lt;command&gt;}"
    where the quotation marks indicate a string and the invoke operator (&amp;)
    causes the command to be executed.

    Example:
        pwsh -Command {Get-WinEvent -LogName security}
        pwsh -command "&amp; {Get-WinEvent -LogName security}"

-ConfigurationName | -config
    Specifies a configuration endpoint in which PowerShell is run.
    This can be any endpoint registered on the local machine including the default PowerShell
    remoting endpoints or a custom endpoint having specific user role capabilities.

    Example: pwsh -ConfigurationName AdminRoles

-CustomPipeName
    Specifies the name to use for an additional IPC server (named pipe) used for debugging 
    and other cross-process communication. This offers a predictable mechanism for connecting
    to other PowerShell instances. Typically used with the CustomPipeName parameter on Enter-PSHostProcess.

    Example: 
    # PowerShell instance 1
    pwsh -CustomPipeName mydebugpipe
    # PowerShell instance 2
    Enter-PSHostProcess -CustomPipeName mydebugpipe

-EncodedCommand | -e | -ec
    Accepts a base64 encoded string version of a command. Use this parameter to submit
    commands to PowerShell that require complex quotation marks or curly braces.

    Example:
        $command = 'dir "c:\program files" '
        $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
        $encodedCommand = [Convert]::ToBase64String($bytes)
        pwsh -encodedcommand $encodedCommand

-ExecutionPolicy | -ex | -ep
    Sets the default execution policy for the current session and saves it
    in the $env:PSExecutionPolicyPreference environment variable.
    This parameter does not change the PowerShell execution policy
    that is set in the registry.

    Example: pwsh -ExecutionPolicy RemoteSigned

-File | -f
    Default parameter if no parameters is present but any values is present in the command line.
    Runs the specified script in the local scope ("dot-sourced"), so that the functions
    and variables that the script creates are available in the current session.
    Enter the script file path and any parameters. File must be the last parameter
    in the command, because all characters typed after the File parameter name are interpreted
    as the script file path followed by the script parameters.

    Example: pwsh HelloWorld.ps1

-Help | -h | -? | /?
    Shows this help message.

-InputFormat | -in | -if
    Describes the format of data sent to PowerShell.
    Valid values are "Text" (text strings) or "XML" (serialized CLIXML format).

-Interactive | -i
    Present an interactive prompt to the user. Inverse for NonInteractive parameter.

-NoExit | -noe
    Does not exit after running startup commands.

    Example: pwsh -NoExit -Command Get-Date

-NoLogo | -nol
    Hides the copyright banner at startup.

-NonInteractive | -noni
    Does not present an interactive prompt to the user. Inverse for Interactive parameter.

-NoProfile | -nop
    Does not load the PowerShell profiles.

-OutputFormat | -o | -of
    Determines how output from PowerShell is formatted. Valid values
    are "Text" (text strings) or "XML" (serialized CLIXML format).
    Default is "Text".

    Example: pwsh -o XML -c Get-Date

-SettingsFile | -settings
    Overrides the system-wide powershell.config.json settings file for the session.
    By default, system-wide settings are read from the powershell.config.json
    in the $PSHOME directory.

    Note that these settings are not used by the endpoint specified
    by the -ConfigurationName argument.

    Example: pwsh -SettingsFile c:\myproject\powershell.config.json

-Version | -v
    Shows the version of PowerShell and exits. Additional arguments are ignored.

    Example: pwsh -v

-WindowStyle | -w
    Sets the window style to Normal, Minimized, Maximized or Hidden.

-WorkingDirectory | -wd
    Sets the working directory at the start of PowerShell given a valid PowerShell directory path.
    Executing `Set-Location -LiteralPath &lt;path&gt;` at startup.

    Example: pwsh -WorkingDirectory ~
    </value>
  </data>
</root>
