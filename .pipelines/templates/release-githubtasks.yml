stages:
- stage: PublishGitHubRelease
  displayName: Publish GitHub Release
  variables:
    ob_release_environment: Test
  jobs:
  - job: GithubReleaseDraft
    displayName: Create GitHub Release Draft
    condition: succeeded()
    pool:
      type: release
      os: windows
    templateContext:
      inputs:
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_deb
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_fxdependent
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_mariner_arm64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_mariner_x64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_minSize
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_rpm
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_tar
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_tar_alpine
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_tar_alpine_fxd
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_tar_arm
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_linux_package_tar_arm64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_mac_package_sign_package_macOS_arm64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_mac_package_sign_package_macOS_x64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_arm64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_fxdependent
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_fxdependentWinDesktop
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_minsize
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_x64
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: drop_windows_package_package_win_x86
        - input: pipelineArtifact
          pipeline: PSPackagesOfficial
          artifactName: macos-pkgs
    variables:
    - name: runCodesignValidationInjection
      value: false
    - name: NugetSecurityAnalysisWarningLevel
      value: none
    - name: DOTNET_SKIP_FIRST_TIME_EXPERIENCE
      value: 1
    - group: 'mscodehub-code-read-akv'
    - group: 'Azure Blob variable group'
    - group: 'GitHubTokens'
    - name: ob_outputDirectory
      value: '$(Build.ArtifactStagingDirectory)/ONEBRANCH_ARTIFACT'
    - name: ob_sdl_codeSignValidation_enabled
      value: false
    - name: ob_sdl_binskim_enabled
      value: false
    - name: ob_sdl_tsa_configFile
      value: $(Build.SourcesDirectory)\PowerShell\.config\tsaoptions.json
    - name: ob_sdl_credscan_suppressionsFile
      value: $(Build.SourcesDirectory)\PowerShell\.config\suppress.json
  
    steps:
    # - checkout: self
    #   clean: true
    #   env:
    #     ob_restore_phase: true # This ensures checkout is done at the beginning of the restore phase
    # - task: Bash@3
    #   inputs:
    #     targetType: inline
    #     script: |
    #       sudo tdnf install -y powershell
    #   displayName: Install PowerShell

    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          git clone https://$(mscodehubCodeReadPat)@mscodehub.visualstudio.com/PowerShellCore/_git/PowerShell '$(Pipeline.Workspace)/PowerShell'
          cd $(Pipeline.Workspace)/PowerShell
          $branchParts = $ENV:BUILD_SOURCEBRANCH -split '/'
          $branchName = "$($branchParts[-2])/$($branchParts[-1])"
          git checkout $branchName
      displayName: Checkout repository

    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          $variable = 'releaseTag'
          $branch = $ENV:BUILD_SOURCEBRANCH
          if($branch -notmatch  '^.*((release/|rebuild/.*rebuild))')
          {
              throw "Branch name is not in release format: '$branch'"
          }
      
          $releaseTag = $Branch -replace '^.*((release|rebuild)/)'
          $vstsCommandString = "vso[task.setvariable variable=$Variable]$releaseTag"
          Write-Verbose -Message "setting $Variable to $releaseTag" -Verbose
          Write-Host -Object "##$vstsCommandString"
      displayName: Set Release Tag
    
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          $azureVersion = '$(ReleaseTag)'.ToLowerInvariant() -replace '\.', '-'
          $vstsCommandString = "vso[task.setvariable variable=AzureVersion]$azureVersion"
          Write-Host "sending " + $vstsCommandString
          Write-Host "##$vstsCommandString"
        
          $version = '$(ReleaseTag)'.ToLowerInvariant().Substring(1)
          $vstsCommandString = "vso[task.setvariable variable=Version]$version"
          Write-Host ("sending " + $vstsCommandString)
          Write-Host "##$vstsCommandString"
      displayName: Set container name
  
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          Get-ChildItem Env: | Out-String -width 9999 -Stream | write-Verbose -Verbose
      displayName: 'Capture Environment Variables'
  
    # - pwsh: |
    #     # Uninstall Azure RM modules
    #     $azRmModules = Get-Module -Name AzureRM* -ListAvailable
    #     if ($azRmModules) {
    #       $azRmModules | Remove-Module -Force
    #     }
    # 
    #     # Install Az.Storage module if not already installed
    #     if (-not (Get-Module -Name Az.Storage -ListAvailable)) {
    #       Install-Module -Name Az.Storage -Force -AllowClobber -Scope CurrentUser -Verbose
    #     }
    #   displayName: Install Az.Storage module
  
    # - task: AzurePowerShell@5
    #   displayName: Download packages from Azure Storage
    #   inputs:
    #     azureSubscription: az-blob-cicd-infra
    #     scriptType: inlineScript
    #     azurePowerShellVersion: LatestVersion
    #     pwsh: true
    #     inline: |
    #       $storageAccount = "$(StorageAccount)"
    #       $containerName = "$(AzureVersion)"
    #       $destinationPath = "$(System.ArtifactsDirectory)"
    # 
    #       # Get storage account context
    #       $storageContext = New-AzStorageContext -StorageAccountName $storageAccount
    # 
    #       $blobList = Get-AzStorageBlob -Container $containerName -Context $storageContext
    #       foreach ($blob in $blobList) {
    #         $blobName = $blob.Name
    #         $destinationFile = Join-Path -Path $destinationPath -ChildPath $blobName
    #         Get-AzStorageBlobContent -Container $containerName -Blob $blobName -Destination $destinationFile -Context $storageContext -Force
    #         Write-Output "Downloaded $blobName to $destinationFile"
    #       }
    # 
    #       $packagesPath = Get-ChildItem -Path $destinationPath\*.deb -Recurse -File | Select-Object -First 1 -ExpandProperty DirectoryName
    #       Write-Host "sending -- vso[task.setvariable variable=PackagesRoot]$packagesPath"
    #       Write-Host "##vso[task.setvariable variable=PackagesRoot]$packagesPath"
  
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          git clone https://$(mscodehubCodeReadPat)@mscodehub.visualstudio.com/PowerShellCore/_git/Internal-PowerShellTeam-Tools '$(Pipeline.Workspace)/tools'
      displayName: Clone Internal-Tools repository

    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          $releaseVersion = '$(ReleaseTag)' -replace '^v',''
          Write-Verbose -Verbose "Moving packages to staging directory"
          $packagesRoot = "$(Pipeline.Workspace)/PSPackagesOfficial"
          New-Item -Path $packagesRoot -ItemType Directory -Force > $null

          Get-ChildItem -Path $(Pipeline.Workspace) | 
            Where-Object { $_.Name -match "powershell-*" -or $_.Name -match "powershell_*" -and -not $_.PSIsContainer } |
            ForEach-Object {
              Move-Item -Path $_.FullName -Destination $packagesRoot
            }

          Write-Verbose -Verbose "List all packages in the staging directory"
          Get-ChildItem -Path $packagesRoot -Recurse | Select-Object -ExpandProperty FullName
      displayName: Move packages to staging directory

    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          $Path = "$(Pipeline.Workspace)/PSPackagesOfficial"
          $OutputPath = Join-Path $Path 'hashes.sha256'
          $srcPaths = @($Path)
          $packages  = Get-ChildItem -Path $srcPaths -Include * -Recurse -File
          $checksums = $packages |
              ForEach-Object {
                  Write-Verbose -Verbose "Generating checksum file for $($_.FullName)"
                  $packageName = $_.Name
                  $hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash.ToLower()
                  # the '*' before the packagename signifies it is a binary
                  "$hash *$packageName"
              }
          $checksums | Out-File -FilePath $OutputPath -Force
          $fileContent = Get-Content -Path $OutputPath -Raw | Out-String
          Write-Verbose -Verbose -Message $fileContent
      displayName: Add sha256 hashes
  
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          $releaseVersion = '$(ReleaseTag)' -replace '^v',''
          $vstsCommandString = "vso[task.setvariable variable=ReleaseVersion]$releaseVersion"
          Write-Host "sending " + $vstsCommandString
          Write-Host "##$vstsCommandString"
      displayName: 'Set release version'

    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          Get-ChildItem $(Pipeline.Workspace) -recurse | Select-Object -ExpandProperty FullName
      displayName: List all files in the workspace
  
    - task: PowerShell@2
      inputs:
        targetType: inline
        script: |
          # Import-module '$(Pipeline.Workspace)/tools/Scripts/GitHubRelease.psm1'
          $releaseVersion = '$(ReleaseTag)' -replace '^v',''
          Write-Verbose -Verbose "Release Version: $releaseVersion"
          # $semanticVersion = [System.Management.Automation.SemanticVersion]$releaseVersion
          Write-Verbose -Verbose "Added Class SemanticVersion because pwsh 7+ is not available"
          class SemanticVersion {
            [int]$Major
            [int]$Minor
            [int]$Patch
            [string]$PreReleaseLabel

            SemanticVersion([string]$releaseVersion) {
              $versionParts = $releaseVersion -split '[.-]'
              for($i = 0; $i -lt $versionParts.Count; $i++) {
                if ($i -eq 0) {
                    $this.Major = [int]$versionParts[$i]
                } elseif ($i -eq 1) {
                    $this.Minor = [int]$versionParts[$i]
                } elseif ($i -eq 2) {
                  $this.Patch = [int]$versionParts[$i]
                } elseif ($i -eq 3) {
                  $this.PreReleaseLabel = $versionParts[$i..($versionParts.Count - 1)] -join '.'
                }
              }
            }
        
            [string] ToString() {
                $version = "$($this.Major).$($this.Minor).$($this.Patch)"
                if ($this.PreReleaseLabel) {
                    $version += "-$($this.PreReleaseLabel)"
                }
                return $version
            }
          }

          $semanticVersion = [SemanticVersion]::new($releaseVersion)
          $isPreview = $semanticVersion.PreReleaseLabel -ne $null
        
          $fileName = if ($isPreview) {
            "preview.md"
          }
          else {
            $semanticVersion.Major.ToString() + "." + $semanticVersion.Minor.ToString() + ".md"
          }
        
          $filePath = "$(Pipeline.Workspace)/PowerShell/CHANGELOG/$fileName"
          Write-Verbose -Verbose "Selected Log file: $filePath"
        
          if (-not (Test-Path $filePath)) {
            throw "$filePath not found"
          }
        
          $changelog = Get-Content -Path $filePath
        
          $startPattern = "^## \[" + ([regex]::Escape($releaseVersion)) + "\]"
          $endPattern = "^## \[{0}\.{1}\.{2}*" -f $semanticVersion.Major, $semanticVersion.Minor, $semanticVersion.Patch
        
          $clContent = $changelog | ForEach-Object {
              if ($_ -match $startPattern) { $outputLine = $true }
              elseif ($_ -match $endPattern) { $outputLine = $false }
              if ($outputLine) { $_}
            } | Out-String
        
          Write-Verbose -Verbose "Selected content: `n$clContent"

          function Find-Release {
            [CmdletBinding(DefaultParameterSetName="Default")]
            param(
              [Parameter(Mandatory)]
              [string]$Tag
            )

            DynamicParam {
              Get-CommonParameters
            }

            Begin {
              Write-Verbose -Message "Finding release for tag '$Tag'" -Verbose
              $User, $Repository, $AuthHeader = Get-CommonParamValues -Cmdlet $PSCmdlet
            }

            End {
              $maxRetries = 10
              $retryIntervalSec = 5
              $attempt = 0
              $success = $false
              $Result = $null

              while (-not $success -and $attempt -lt $maxRetries) {
                try {
                  Write-Verbose -Message "Retrieving releases for $User/$Repository" -Verbose
                  $Result = Invoke-RestMethod -Uri "https://api.github.com/repos/$User/$Repository/releases"
                  Write-Verbose -Message "Result from Invoke-RestMethod: $Result" -Verbose
                  $success = $true
                } catch {
                  $attempt++
                  if ($attempt -lt $maxRetries) {
                    Start-Sleep -Seconds $retryIntervalSec
                  } else {
                    throw "Failed to retrieve releases after $maxRetries attempts."
                  }
                }
              }

              if (-not [string]::IsNullOrWhiteSpace($Result.Content)) {
                try {
                  Write-Verbose -Message "This is the Response Content: $($Result.Content)" -Verbose
                  $Releases = $Result.Content | ConvertFrom-Json
                } catch {
                  Write-Verbose -Message "This was the Response: $Result" -Verbose
                  throw "Failed to convert response from JSON: $_"
                }
    
                foreach ($Item in $Releases) {
                  if ($Item.tag_name -eq $Tag) {
                    Write-Verbose ("Release $Tag is found, upload_url=" + $Item.upload_url) -Verbose
                    return $Item.id
                  }
                }
              } else {
                throw "Response content is empty or invalid."
              }
            }
          }

          function New-Release {
            [CmdletBinding(DefaultParameterSetName="Default")]
            param(
              [Parameter(Mandatory)]
              [string]$Tag,
      
              [Parameter(Mandatory)]
              [string]$Name,
      
              [Parameter(Mandatory)]
              [string]$Description
            )
        
            DynamicParam {
              Get-CommonParameters
            }
        
            Begin {
              Write-Verbose -Message "Creating a new release draft for $Tag" -Verbose
              $User, $Repository, $AuthHeader = Get-CommonParamValues -Cmdlet $PSCmdlet
            }

            End {
              $maxRetries = 10
              $retryIntervalSec = 5
              $attempt = 0
              $success = $false
      
              $Body = @{
                tag_name = $Tag
                name = $Name
                body = $Description
                draft = $true
                prerelease = $false
              }
      
              $BodyInJson = $Body | ConvertTo-Json
      
              while (-not $success -and $attempt -lt $maxRetries) {
                try {
                  $Result = Invoke-RestMethod -Headers $AuthHeader -Method Post -Body $BodyInJson -Uri "https://api.github.com/repos/$User/$Repository/releases"
                  $success = $true
                } catch {
                  $attempt++
                  if ($attempt -lt $maxRetries) {
                    Start-Sleep -Seconds $retryIntervalSec
                  } else {
                    throw "Failed to create release after $maxRetries attempts."
                  }
                }
              }
              
              if (-not [string]::IsNullOrWhiteSpace($Result.Content)) {
                try {
                  Write-Verbose -Message "This is the Response Content: $($Result.Content)" -Verbose
                  $Release = $Result | ConvertFrom-Json
                } catch {
                  Write-Verbose -Message "This was the Response: $Result" -Verbose
                  throw "Failed to convert response from JSON: $_"
                }
                return $Release.id
              } else {
                throw "Response content is empty or invalid."
              }
            }
          }

          function Find-ReleaseAsset {
            [CmdletBinding(DefaultParameterSetName="Default")]
            param(
              [Parameter(Mandatory)]
              [int]$ReleaseId,
      
              [Parameter(Mandatory)]
              [string]$AssetName
            )
        
            DynamicParam {
              Get-CommonParameters
            }
        
            Begin {
              Write-Verbose -Message "Searching for asset '$AssetName' in release $ReleaseId" -Verbose
              $User, $Repository, $AuthHeader = Get-CommonParamValues -Cmdlet $PSCmdlet
            }

            End {
              $maxRetries = 10
              $retryIntervalSec = 5
              $attempt = 0
              $success = $false
      
              while (-not $success -and $attempt -lt $maxRetries) {
                try {
                  $Result = Invoke-RestMethod -Headers $AuthHeader -Uri "https://api.github.com/repos/$User/$Repository/releases/$ReleaseId/assets"
                  $success = $true
                } catch {
                  $attempt++
                  if ($attempt -lt $maxRetries) {
                      Start-Sleep -Seconds $retryIntervalSec
                  } else {
                      throw "Failed to retrieve assets after $maxRetries attempts."
                  }
                }
              }

              if (-not [string]::IsNullOrWhiteSpace($Result.Content)) {
                try {
                  Write-Verbose -Message "This is the Response Content: $($Result.Content)" -Verbose
                  $Assets = $Result | ConvertFrom-Json
                  foreach ($Item in $Assets) {
                    if ($Item.name -eq $AssetName) {
                      Write-Verbose "Asset $AssetName was already uploaded, id: $($Item.id)" -Verbose
                      Write-Verbose ("  Asset is ready for download: " + $Item.browser_download_url) -Verbose
                      return $Item.id
                    }
                  }
                } catch {
                  Write-Verbose -Message "This was the Response: $Result" -Verbose
                  throw "Failed to convert response from JSON: $_"
                }
              } else {
                throw "Response content is empty or invalid."
              }
            }
          }

          function Push-ReleaseAsset {
            [CmdletBinding(DefaultParameterSetName="Default")]
            param(
              [Parameter(Mandatory)]
              [int]$ReleaseId,
      
              [Parameter(Mandatory)]
              [string]$AssetPath,
      
              [switch]$PassThru
            )
        
            DynamicParam {
              Get-CommonParameters
            }
        
            Begin {
              Write-Verbose -Message "Pushing asset '$AssetPath' to release $ReleaseId" -Verbose
              $User, $Repository, $AuthHeader = Get-CommonParamValues -Cmdlet $PSCmdlet
            }
        
            End {
              $maxRetries = 10
              $retryIntervalSec = 5
              $attempt = 0
              $success = $false
      
              $type_7z  = "application/octet-stream"
              $type_exe = "application/x-msdownload"
      
              $AssetName = Split-Path $AssetPath -Leaf
      
              if ([System.IO.Path]::GetExtension($AssetName) -eq ".7z") {
                $content_type = $type_7z
              } else {
                $content_type = $type_exe
              }
      
              $Header = $AuthHeader + @{"Content-Type"=$content_type; "name"=$AssetName;}
              $Uri = "https://uploads.github.com/repos/$User/$Repository/releases/$ReleaseId/assets?name=$AssetName"
      
              $Body = [System.IO.File]::ReadAllBytes($AssetPath)
      
              while (-not $success -and $attempt -lt $maxRetries) {
                try {
                  $Result = Invoke-RestMethod -Headers $Header -Method Post -Body $Body -Uri $Uri
                  $success = $true
                } catch {
                  $attempt++
                  if ($attempt -lt $maxRetries) {
                      Start-Sleep -Seconds $retryIntervalSec
                  } else {
                      throw "Failed to upload asset after $maxRetries attempts."
                  }
                }
              }
      
              if ($Result.StatusCode -eq 201) {
                Write-Verbose -Message "This is the Response Content: $($Result.Content)" -Verbose
                $Content = $Result | ConvertFrom-Json
                Write-Host "'$AssetName' -- Upload succeeded" -ForegroundColor Green
                Write-Verbose -Message "   Download URL: $($Content.browser_download_url)" -Verbose
              } else {
                Write-Host "'$AssetName' -- Upload failed with StatusCode $($Result.StatusCode)" -ForegroundColor Red
              }
      
              ## Pass through the HTTP result if '-PassThru' is specified
              if ($PassThru) { return $Result }
            }
          }
          
          $Script:Auth = $null

          function Get-CommonParameters {
            $ParamDict = [System.Management.Automation.RuntimeDefinedParameterDictionary]::new()

            ## Add the '-User' parameter
            ## [Parameter(Mandatory)]
            ## [string]$User
            $UserAtts = [System.Collections.ObjectModel.Collection[System.Attribute]]::new()
            $UserAtts.Add([System.Management.Automation.ParameterAttribute]@{Mandatory = $true}) > $null
            $ParamDict.Add("User", [System.Management.Automation.RuntimeDefinedParameter]::new("User", [string], $UserAtts)) > $null

            ## Add the '-Repository' parameter
            ## [Parameter(Mandatory)]
            ## [string]$Repository
            $RepositoryAtts = [System.Collections.ObjectModel.Collection[System.Attribute]]::new()
            $RepositoryAtts.Add([System.Management.Automation.ParameterAttribute]@{Mandatory = $true}) > $null
            $ParamDict.Add("Repository", [System.Management.Automation.RuntimeDefinedParameter]::new("Repository", [string], $RepositoryAtts)) > $null

            ## Add the '-Token' parameter
            ## [Parameter(Mandatory, ParameterSetName="UseSpecifiedToken")]
            ## [string]$Token
            $TokenAtts = [System.Collections.ObjectModel.Collection[System.Attribute]]::new()
            $TokenAtts.Add([System.Management.Automation.ParameterAttribute]@{Mandatory = $true; ParameterSetName="UseSpecifiedToken"}) > $null
            $ParamDict.Add("Token", [System.Management.Automation.RuntimeDefinedParameter]::new("Token", [string], $TokenAtts)) > $null

            return $ParamDict
          }

          function Get-CommonParamValues([System.Management.Automation.PSCmdlet]$Cmdlet) {
            $AuthHeader = $Script:Auth
            if ($Cmdlet.ParameterSetName -eq "UseSpecifiedToken") {
              $Token = $Cmdlet.MyInvocation.BoundParameters["Token"]
              $AuthHeader = @{"Authorization"="token $Token"}
            }
            if (-not $AuthHeader) {
              throw "Authentication token is not specified."
            }
          
            $User = $Cmdlet.MyInvocation.BoundParameters["User"]
            $Repository = $Cmdlet.MyInvocation.BoundParameters["Repository"]
            return $User, $Repository, $AuthHeader
          }

          function Publish-ReleaseDraft {
            [CmdletBinding(DefaultParameterSetName="Default")]
            param(
              [Parameter(Mandatory)]
              [string]$Tag,
      
              [Parameter(Mandatory)]
              [string]$Name,
      
              [Parameter(Mandatory)]
              [string]$Description,
      
              [Parameter(Mandatory)]
              [string]$PackageFolder
            )
        
            DynamicParam { Get-CommonParameters }
        
            Begin {
              Write-Verbose -Message "Publishing release draft for $Tag" -Verbose
              $User, $Repository, $AuthHeader = Get-CommonParamValues -Cmdlet $PSCmdlet
              $Script:Auth = $AuthHeader
              $CommonParams = @{User=$User; Repository=$Repository}
            }
        
            End {
              $ReleaseId = Find-Release -Tag $Tag @CommonParams
              if ($ReleaseId) {
                Write-Host "Release for $Tag already created, Release-Id: $ReleaseId" -ForegroundColor Green
              } else {
                $StringBuilder = [System.Text.StringBuilder]::new($Description, $Description.Length + 2kb)
                $StringBuilder.AppendLine().AppendLine() > $null
                $StringBuilder.AppendLine("### SHA256 Hashes of the release artifacts").AppendLine() > $null
                Get-ChildItem -Path $PackageFolder -File | ForEach-Object {
                  $PackageName = $_.Name
                  $SHA256 = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash
                  $StringBuilder.AppendLine("- $PackageName").AppendLine("  - $SHA256") > $null
                }
    
                $Description = $StringBuilder.ToString()
                $ReleaseId = New-Release -Tag $Tag -Name $Name -Description $Description @CommonParams
                Write-Host "Release for $Tag created, Release-Id: $ReleaseId" -ForegroundColor Green
              }
      
              Get-ChildItem -Path $PackageFolder -File | ForEach-Object {
                $PackageName = $_.Name
                $PackageId = Find-ReleaseAsset -ReleaseId $ReleaseId -AssetName $PackageName @CommonParams
                if (-not $PackageId) {
                  Push-ReleaseAsset -ReleaseId $ReleaseId -AssetPath $_.FullName @CommonParams
                }
              }
            }
          }
        
          $clContent = "Testing... DeployBox... `n`n" + $clContent
          
          Publish-ReleaseDraft -Tag '$(ReleaseTag)' -Name '$(ReleaseTag) Release of PowerShell' -Description $clContent -User PowerShell -Repository PowerShell  -PackageFolder "$(Pipeline.Workspace)/PSPackagesOfficial" -Token $(GitHubReleasePat)
      displayName: Publish Release Draft
  
  # - job: PushGitTag
  #   displayName: Push Git Tag
  #   pool:
  #     type: server
  #   timeoutInMinutes: 4320 # job times out in 3 days
  #   steps:
  #   - task: ManualValidation@0
  #     displayName: Push Git Tag
  #     timeoutInMinutes: 2880
  #     inputs:
  #       instructions: Push the git tag to upstream
  #       onTimeout: reject
  #       notifyUsers: ''
# 
  # - job: DraftPublic
  #   displayName: Make Draft Public
  #   pool:
  #     type: server
  #   timeoutInMinutes: 4320 # job times out in 3 days
  #   steps:
  #   - task: ManualValidation@0
  #     displayName: Make Draft Public
  #     timeoutInMinutes: 2880
  #     inputs:
  #       instructions: Make the GitHub Release Draft Public
  #       onTimeout: reject
  #       notifyUsers: ''

  # - template: /.pipelines/templates/approvalJob.yml@self
  #   parameters:
  #     displayName: Push Git Tag
  #     jobName: PushGitTag
  #     dependsOnJob: GithubReleaseDraft
  #     instructions: |
  #       Push the git tag to upstream
  
  # - template: /.pipelines/templates/approvalJob.yml@self
  #   parameters:
  #     displayName: Make Draft Public
  #     jobName: DraftPublic
  #     dependsOnJob: PushGitTag
  #     instructions: |
  #       Make the GitHub Release Draft Public
  