parameters:
  - name: OfficialBuild
    type: boolean
    default: false

jobs:
- job: CreateMSIXBundle
  displayName: Create .msixbundle file
  pool:
    type: windows

  variables:
    - group: msixTools
    - group: 'Azure Blob variable group'
    - group: 'Store Publish Variables'
    - name: ob_sdl_credscan_suppressionsFile
      value: $(Build.SourcesDirectory)\PowerShell\.config\suppress.json
    - name: ob_sdl_tsa_configFile
      value: $(Build.SourcesDirectory)\PowerShell\.config\tsaoptions.json
    - name: ob_outputDirectory
      value: '$(Build.ArtifactStagingDirectory)/ONEBRANCH_ARTIFACT'

  steps:
    - checkout: self
      clean: true
      env:
        ob_restore_phase: true # This ensures checkout is done at the beginning of the restore phase

    - template: release-SetReleaseTagandContainerName.yml@self

    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        artifact: drop_windows_package_arm64
        itemPattern: |
          **/*.msix
        targetPath: '$(Build.ArtifactStagingDirectory)/downloads'
      displayName: Download windows arm64 packages

    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        artifact: drop_windows_package_x64
        itemPattern: |
          **/*.msix
        targetPath: '$(Build.ArtifactStagingDirectory)/downloads'
      displayName: Download windows x64 packages

    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        artifact: drop_windows_package_x86
        itemPattern: |
          **/*.msix
        targetPath: '$(Build.ArtifactStagingDirectory)/downloads'
      displayName: Download windows x86 packages

    # Finds the makeappx tool on the machine with image: 'onebranch.azurecr.io/windows/ltsc2022/vse2022:latest'
    - pwsh: |
        $cmd = Get-Command makeappx.exe -ErrorAction Ignore
        if ($cmd) {
            Write-Verbose -Verbose 'makeappx available in PATH'
            $exePath = $cmd.Source
        } else {
            $toolsDir = '$(Pipeline.Workspace)\releasePipeline\tools'
            New-Item $toolsDir -Type Directory -Force > $null
            $makeappx = Get-ChildItem -Recurse 'C:\Program Files (x86)\Windows Kits\10\makeappx.exe' |
              Where-Object { $_.DirectoryName -match 'x64' } |
              Select-Object -Last 1
            $exePath = $makeappx.FullName
            Write-Verbose -Verbose 'makeappx was found:'
        }
        $vstsCommandString = "vso[task.setvariable variable=MakeAppxPath]$exePath"
        Write-Host "sending " + $vstsCommandString
        Write-Host "##$vstsCommandString"
      displayName: Find makeappx tool
      retryCountOnTaskFailure: 1

    - pwsh: |
        $sourceDir = '$(Pipeline.Workspace)\releasePipeline\msix'
        $null = New-Item -Path $sourceDir -ItemType Directory -Force

        $msixFiles = Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)/downloads/*.msix" -Recurse
        foreach ($msixFile in $msixFiles) {
            $null = Copy-Item -Path $msixFile.FullName -Destination $sourceDir -Force -Verbose
        }

        $file = Get-ChildItem $sourceDir | Select-Object -First 1
        $prefix = ($file.BaseName -split "-win")[0]
        $pkgName = "$prefix.msixbundle"
        Write-Verbose -Verbose "Creating $pkgName"

        $makeappx = '$(MakeAppxPath)'
        $outputDir = "$sourceDir\output"
        New-Item $outputDir -Type Directory -Force > $null
        & $makeappx bundle /d $sourceDir /p "$outputDir\$pkgName"

        Get-ChildItem -Path $sourceDir -Recurse
        $vstsCommandString = "vso[task.setvariable variable=BundleDir]$outputDir"
        Write-Host "sending " + $vstsCommandString
        Write-Host "##$vstsCommandString"
      displayName: Create MsixBundle
      retryCountOnTaskFailure: 1

    - task: onebranch.pipeline.signing@1
      displayName: Sign MsixBundle
      condition: eq('${{ parameters.OfficialBuild }}', 'true')
      inputs:
        command: 'sign'
        signing_profile: $(MSIXProfile)
        files_to_sign: '**/*.msixbundle'
        search_root: '$(BundleDir)'

    - pwsh: |
        $signedBundle = Get-ChildItem -Path $(BundleDir) -Filter "*.msixbundle" -File
        Write-Verbose -Verbose "Signed bundle: $signedBundle"

        if (-not (Test-Path $(ob_outputDirectory))) {
          New-Item -ItemType Directory -Path $(ob_outputDirectory) -Force
        }

        Copy-Item -Path $signedBundle.FullName -Destination "$(ob_outputDirectory)" -Verbose

        Write-Verbose -Verbose "Uploaded Bundle:"
        Get-ChildItem -Path $(ob_outputDirectory) | Write-Verbose -Verbose
      displayName: Upload msixbundle to Artifacts

    - pwsh: |
        Write-Verbose -Verbose "Pipeline.Workspace: $(Pipeline.Workspace)"
        Get-ChildItem -Path $(Pipeline.Workspace) -Recurse | Select-Object -ExpandProperty FullName
        Write-Verbose -Verbose "System.DefaultWorkingDirectory: $(System.DefaultWorkingDirectory)"
        Get-ChildItem -Path $(System.DefaultWorkingDirectory) -Recurse | Select-Object -ExpandProperty FullName
        Test-Path -Path '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP-Private.xml' | Write-Verbose -Verbose
      displayName: Output Pipeline.Workspace and System.DefaultWorkingDirectory

    - template: channelSelection.yml@self

    - pwsh: |
        $IsLTS = '$(ChannelSelection.IsLTS)' -eq 'true'
        $IsStable = '$(ChannelSelection.IsStable)' -eq 'true'
        $IsPreview = '$(ChannelSelection.IsPreview)' -eq 'true'

        Write-Verbose -Verbose "Channel Selection - LTS: $IsLTS, Stable: $IsStable, Preview: $IsPreview"

        # Define app configurations for each channel
        $channelConfigs = @{
          'LTS' = @{
            AppStoreName = 'PowerShell-LTS'
            ProductId = '$(productId-LTS)'
            AppId = '$(AppID-LTS)'
            ServiceEndpoint = "StoreAppPublish-Stable"
          }
          'Stable' = @{
            AppStoreName = 'PowerShell'
            ProductId = '$(productId-Stable)'
            AppId = '$(AppID-Stable)'
            ServiceEndpoint = "StoreAppPublish-Stable"
          }
          'Preview' = @{
            AppStoreName = 'PowerShell (Preview)'
            ProductId = '$(productId-Preview)'
            AppId = '$(AppID-Preview)'
            ServiceEndpoint = "StoreAppPublish-Preview"
          }
        }

        $currentChannel = if ($IsLTS) { 'LTS' }
          elseif ($IsStable) { 'Stable' }
          elseif ($IsPreview) { 'Preview' }
          else {
            Write-Error "No valid channel detected"
            exit 1
          }

        $config = $channelConfigs[$currentChannel]
        Write-Verbose -Verbose "Selected channel: $currentChannel"
        Write-Verbose -Verbose "App Store Name: $($config.AppStoreName)"
        Write-Verbose -Verbose "Product ID: $($config.ProductId)"

        # Update PDP.xml file
        $pdpPath = '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP/PDP/en-US/PDP.xml'
        if (Test-Path $pdpPath) {
          Write-Verbose -Verbose "Updating PDP file: $pdpPath"

          [xml]$pdpXml = Get-Content $pdpPath -Raw

          # Create namespace manager for XML with default namespace
          $nsManager = New-Object System.Xml.XmlNamespaceManager($pdpXml.NameTable)
          $nsManager.AddNamespace("pd", "http://schemas.microsoft.com/appx/2012/ProductDescription")

          $appStoreNameElement = $pdpXml.SelectSingleNode("//pd:AppStoreName", $nsManager)
          if ($appStoreNameElement) {
            $appStoreNameElement.SetAttribute("_locID", $config.AppStoreName)
            Write-Verbose -Verbose "Updated AppStoreName _locID to: $($config.AppStoreName)"
          } else {
            Write-Warning "AppStoreName element not found in PDP file"
          }

          $pdpXml.Save($pdpPath)
          Write-Verbose -Verbose "PDP file updated successfully"
          Get-Content -Path $pdpPath | Write-Verbose -Verbose
        } else {
          Write-Error "PDP file not found: $pdpPath"
          exit 1
        }

        # Update SBConfig.json file
        $sbConfigPath = '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/SBConfig.json'
        if (Test-Path $sbConfigPath) {
          Write-Verbose -Verbose "Updating SBConfig file: $sbConfigPath"

          $sbConfigJson = Get-Content $sbConfigPath -Raw | ConvertFrom-Json

          $sbConfigJson.appSubmission.productId = $config.ProductId
          Write-Verbose -Verbose "Updated productId to: $($config.ProductId)"

          $sbConfigJson | ConvertTo-Json -Depth 100 | Set-Content $sbConfigPath -Encoding UTF8
          Write-Verbose -Verbose "SBConfig file updated successfully"
          Get-Content -Path $sbConfigPath | Write-Verbose -Verbose
        } else {
          Write-Error "SBConfig file not found: $sbConfigPath"
          exit 1
        }

        Write-Host "##vso[task.setvariable variable=ServiceConnection]$($config.ServiceEndpoint)"
        Write-Host "##vso[task.setvariable variable=SBConfigPath]$($sbConfigPath)"

        # These variables are used in the next tasks to determine which ServiceEndpoint to use
        $ltsValue = $IsLTS.ToString().ToLower()
        $stableValue = $IsStable.ToString().ToLower()
        $previewValue = $IsPreview.ToString().ToLower()

        Write-Verbose -Verbose "About to set variables:"
        Write-Verbose -Verbose "  LTS=$ltsValue"
        Write-Verbose -Verbose "  STABLE=$stableValue"
        Write-Verbose -Verbose "  PREVIEW=$previewValue"

        Write-Host "##vso[task.setvariable variable=LTS]$ltsValue"
        Write-Host "##vso[task.setvariable variable=STABLE]$stableValue"
        Write-Host "##vso[task.setvariable variable=PREVIEW]$previewValue"

        Write-Verbose -Verbose "Variables set successfully"
      name: UpdateConfigs
      displayName: Update PDPs and SBConfig.json

    - pwsh: |
        Write-Verbose -Verbose "Checking variables after UpdateConfigs:"
        Write-Verbose -Verbose "LTS=$(LTS)"
        Write-Verbose -Verbose "STABLE=$(STABLE)"
        Write-Verbose -Verbose "PREVIEW=$(PREVIEW)"
      displayName: Debug - Check Variables

    - task: MS-RDX-MRO.windows-store-publish.package-task.store-package@3
      displayName: 'Create StoreBroker Package (Preview)'
      condition: eq('$(PREVIEW)', 'true')
      inputs:
        serviceEndpoint: 'StoreAppPublish-Preview'
        sbConfigPath: '$(SBConfigPath)'
        sourceFolder: '$(BundleDir)'
        contents: '*.msixBundle'
        outSBName: 'PowerShellStorePackage'
        pdpPath: '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP/PDP'
        pdpMediaPath: '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP/PDP-Media'

    - task: MS-RDX-MRO.windows-store-publish.package-task.store-package@3
      displayName: 'Create StoreBroker Package (Stable/LTS)'
      condition: or(eq('$(STABLE)', 'true'), eq('$(LTS)', 'true'))
      inputs:
        serviceEndpoint: 'StoreAppPublish-Stable'
        sbConfigPath: '$(SBConfigPath)'
        sourceFolder: '$(BundleDir)'
        contents: '*.msixBundle'
        outSBName: 'PowerShellStorePackage'
        pdpPath: '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP/PDP'
        pdpMediaPath: '$(System.DefaultWorkingDirectory)/PowerShell/.pipelines/store/PDP/PDP-Media'

    - pwsh: |
        Get-Item -Path "$(System.DefaultWorkingDirectory)/SBLog.txt" -ErrorAction SilentlyContinue |
          Copy-Item -Destination "$(ob_outputDirectory)" -Verbose
      displayName: Upload Store Failure Log
      condition: failed()

    - pwsh: |
        $submissionPackageDir = "$(System.DefaultWorkingDirectory)/SBOutDir"
        $jsonFile = "$submissionPackageDir/PowerShellStorePackage.json"
        $zipFile = "$submissionPackageDir/PowerShellStorePackage.zip"

        if ((Test-Path $jsonFile) -and (Test-Path $zipFile)) {
          Write-Verbose -Verbose "Uploading StoreBroker Package files:"
          Write-Verbose -Verbose "JSON File: $jsonFile"
          Write-Verbose -Verbose "ZIP File: $zipFile"

          Copy-Item -Path $submissionPackageDir -Destination "$(ob_outputDirectory)" -Verbose -Recurse
        }

        else {
          Write-Error "Required files not found in $submissionPackageDir"
        }
      displayName: 'Upload StoreBroker Package'
