# This Yaml Document has been converted by ESAI Yaml Pipeline Conversion Tool.
# Please make sure to check all the converted content, it is your team's responsibility to make sure that the pipeline is still valid and functions as expected.
parameters:
  buildName: ''
  uploadDisplayName: 'Upload'
jobs:
- job: pkg_${{ parameters.buildName }}
  displayName: Package ${{ parameters.buildName }}
  condition: succeeded()
  pool:
    type: linux
  variables:
  - name: runCodesignValidationInjection
    value: false
  - name: build
    value: ${{ parameters.buildName }}
  - name: NugetSecurityAnalysisWarningLevel
    value: none
  - group: ESRP
  - group: DotNetPrivateBuildAccess
  - name: ob_outputDirectory
    value: '$(Build.ArtifactStagingDirectory)/ONEBRANCH_ARTIFACT'
  steps:
  - ${{ if or(eq(variables.build,'deb'), eq(variables.build,'rpm')) }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-signed
        pattern: '**/pwshLinuxBuild.tar.gz'
      displayName: Download deb build
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize-signed
        pattern: '**/pwshLinuxBuildMinSize.tar.gz'
      displayName: Download min-size build
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32-signed
        pattern: '**/pwshLinuxBuildArm32.tar.gz'
      displayName: Download arm32 build
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64-signed
        pattern: '**/pwshLinuxBuildArm64.tar.gz'
      displayName: Download arm64 build
  - ${{ if eq(variables.build,'rpm') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64-signed
        pattern: '**/pwshMarinerBuildAmd64.tar.gz'
      displayName: Download mariner amd64 build
  - ${{ if eq(variables.build,'rpm') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64-signed
        pattern: '**/pwshMarinerBuildArm64.tar.gz'
      displayName: Download mariner arm64 build
  - ${{ if eq(variables.build,'alpine') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildAlpine-signed
        pattern: '**/pwshLinuxBuildAlpine.tar.gz'
      displayName: Download alpine build
  - ${{ if eq(variables.build,'alpine') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64-signed
        pattern: '**/pwshAlpineFxdBuildAmd64.tar.gz'
      displayName: Download alpine framework dependent build
  - ${{ if eq(variables.build,'fxdependent') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: authenticode-signed
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildFxdependent-signed
        pattern: '**/pwshLinuxBuildFxdependent.tar.gz'
      displayName: Download fxdependent build
  - ${{ if or(eq(variables.build,'deb'), eq(variables.build,'rpm')) }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuild-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-meta
      displayName: Download deb build meta
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuildMinSize-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize-meta
      displayName: Download min-size build meta
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuildArm32-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32-meta
      displayName: Download arm32 build meta
  - ${{ if eq(variables.build,'deb') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuildArm64-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64-meta
      displayName: Download arm64 build meta
  - ${{ if eq(variables.build,'rpm') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshMarinerBuildAmd64-meta
        path: $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64-meta
      displayName: Download mariner x64 build meta
  - ${{ if eq(variables.build,'rpm') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshMarinerBuildArm64-meta
        path: $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64-meta
      displayName: Download mariner arm64 build meta
  - ${{ if eq(variables.build,'alpine') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuildAlpine-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-meta
      displayName: Download alpine build meta
  - ${{ if eq(variables.build,'alpine') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshAlpineFxdBuildAmd64-meta
        path: $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64-meta
      displayName: Download alpine build meta
  - ${{ if eq(variables.build,'fxdependent') }}:
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: pwshLinuxBuildFxdependent-meta
        path: $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-meta
      displayName: Download fxdependent build meta
  - pwsh: |
      Get-ChildItem '$(Build.ArtifactStagingDirectory)' | Select-Object -Property 'unixmode', 'size', 'name'
    displayName: Capture downloads
  - pwsh: |
      if ('$(build)' -eq 'deb' -or '$(build)' -eq 'rpm') {
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-signed/pwshLinuxBuild.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuild"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuild -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshLinuxBuild-signed/pwshLinuxBuild.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuild
      }
      if ('$(build)' -eq 'deb') {
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize-signed/pwshLinuxBuildMinSize.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize-signed/pwshLinuxBuildMinSize.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuildMinSize
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32-signed/pwshLinuxBuildArm32.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32 -ItemType Directory
        tar -xf  $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32-signed/pwshLinuxBuildArm32.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm32
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64-signed/pwshLinuxBuildArm64.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64 -ItemType Directory
        tar -xf  $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64-signed/pwshLinuxBuildArm64.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuildArm64
      }
      if ('$(build)' -eq 'rpm') {
        # for mariner x64
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64-signed/pwshMarinerBuildAmd64.tar.gz to $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64 -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64-signed/pwshMarinerBuildAmd64.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshMarinerBuildAmd64
        # for mariner arm64
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64-signed/pwshMarinerBuildArm64.tar.gz to $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64 -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64-signed/pwshMarinerBuildArm64.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshMarinerBuildArm64
      }
      if ('$(build)' -eq 'alpine') {
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuildAlpine-signed/pwshLinuxBuildAlpine.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuild"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuild -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshLinuxBuildAlpine-signed/pwshLinuxBuildAlpine.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuild
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64-signed/pwshAlpineFxdBuildAmd64.tar.gz to $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64 -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64-signed/pwshAlpineFxdBuildAmd64.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshAlpineFxdBuildAmd64
      }
      if ('$(build)' -eq 'fxdependent') {
        Write-Verbose -Verbose "Expanding $(Build.ArtifactStagingDirectory)/pwshLinuxBuildFxdependent-signed/pwshLinuxBuildFxdependent.tar.gz to $(Build.ArtifactStagingDirectory)/pwshLinuxBuild"
        New-Item -Path $(Build.ArtifactStagingDirectory)/pwshLinuxBuild -ItemType Directory
        tar -xf $(Build.ArtifactStagingDirectory)/pwshLinuxBuildFxdependent-signed/pwshLinuxBuildFxdependent.tar.gz -C $(Build.ArtifactStagingDirectory)/pwshLinuxBuild
      }
    displayName: Expand all signed tar.gz
  - pwsh: |
      Get-ChildItem '$(Build.ArtifactStagingDirectory)' | Select-Object -Property 'unixmode', 'size', 'name'
    displayName: Capture expanded
  - checkout: self
    clean: true
  - checkout: ComplianceRepo
    clean: true
  - template: /.pipelines/templates/SetVersionVariables.yml@self
    parameters:
      ReleaseTagVar: $(ReleaseTagVar)
  - pwsh: |
      # create folder
      sudo mkdir /PowerShell
      # make the current user the owner
      $userName = whoami
      Write-Verbose -Verbose "Current user: $userName"
      sudo chown $userName /PowerShell
    displayName: 'Create /PowerShell'
  - template: /.pipelines/templates/cloneToOfficialPath.yml@self
  - template: /.pipelines/templates/insert-nuget-config-azfeed.yml@self
    parameters:
      repoRoot: $(PowerShellRoot)
  - powershell: |
      import-module "$env:POWERSHELLROOT/build.psm1"
      Sync-PSTags -AddRemoteIfMissing
    displayName: SyncTags
    condition: and(succeeded(), ne(variables['SkipBuild'], 'true'))
    workingDirectory: $(PowerShellRoot)
  - powershell: |
      Import-Module "$env:POWERSHELLROOT/build.psm1"
      Start-PSBootstrap -Package
    displayName: 'Bootstrap'
    condition: and(succeeded(), ne(variables['SkipBuild'], 'true'))
    workingDirectory: $(PowerShellRoot)
    env:
      __DOTNET_RUNTIME_FEED_KEY: $(RUNTIME_SOURCEFEED_KEY)
  - powershell: |
      try {
        Import-Module "$env:POWERSHELLROOT/build.psm1"
        Import-Module "$env:POWERSHELLROOT/tools/packaging"
        $metadata = Get-Content "$env:POWERSHELLROOT/tools/metadata.json" -Raw | ConvertFrom-Json
        # LTSRelease.Package indicates that the release should be packaged as an LTS
        $LTS = $metadata.LTSRelease.Package
        Write-Verbose -Verbose -Message "LTS is set to: $LTS"
        Invoke-AzDevOpsLinuxPackageCreation -ReleaseTag '$(ReleaseTagVar)' -BuildType '$(build)'
        if ($LTS) {
            Write-Verbose -Verbose "Packaging LTS"
            Invoke-AzDevOpsLinuxPackageCreation -LTS  -ReleaseTag '$(ReleaseTagVar)' -BuildType '$(build)'
        }
      } catch {
        Get-Error
        throw
      }
    displayName: 'Package'
    condition: and(succeeded(), ne(variables['SkipBuild'], 'true'))
    workingDirectory: $(PowerShellRoot)
  - powershell: |
      $linuxPackages = Get-ChildItem "$env:POWERSHELLROOT/powershell*" -Include *.deb,*.rpm,*.tar.gz
      $bucket = 'release'
      foreach ($linuxPackage in $linuxPackages)
      {
          $filePath = $linuxPackage.FullName
          Write-Verbose "Publishing $filePath to $bucket" -Verbose
          Write-Host "##vso[artifact.upload containerfolder=$bucket;artifactname=$bucket]$filePath"
      }
    displayName: Publish artifacts
    condition: and(succeeded(), ne(variables['SkipBuild'], 'true'))
    workingDirectory: $(PowerShellRoot)
    retryCountOnTaskFailure: 2
  - template: /.pipelines/templates/step/finalize.yml@self
- job: upload_${{ parameters.buildName }}
  displayName: ${{ parameters.uploadDisplayName }} ${{ parameters.buildName }}
  dependsOn: pkg_${{ parameters.buildName }}
  condition: succeeded()
  pool:
    type: windows
  variables:
  - name: buildName
    value: ${{ parameters.buildName }}
  - group: ESRP
  - name: runCodesignValidationInjection
    value: false
  - name: NugetSecurityAnalysisWarningLevel
    value: none
  - name: skipComponentGovernanceDetection
    value: true
  - name: ob_outputDirectory
    value: '$(Build.ArtifactStagingDirectory)/ONEBRANCH_ARTIFACT'
  - group: AzureBlobServiceConnection
  steps:
  - checkout: self
    clean: true
  - checkout: ComplianceRepo
    clean: true
  - template: /.pipelines/templates/SetVersionVariables.yml@self
    parameters:
      ReleaseTagVar: $(ReleaseTagVar)
  - template: /.pipelines/templates/shouldSign.yml@self
  - task: DownloadBuildArtifacts@0
    displayName: 'Download Deb Artifacts'
    inputs:
      downloadType: specific
      itemPattern: '**/*.deb'
      downloadPath: '$(System.ArtifactsDirectory)\finished'
    condition: and(eq(variables['buildName'], 'DEB'), succeeded())
  - task: DownloadBuildArtifacts@0
    displayName: 'Download tar.gz Artifacts copy'
    inputs:
      downloadType: specific
      itemPattern: '**/*.tar.gz'
      downloadPath: '$(System.ArtifactsDirectory)\finished'
  - powershell: |
      Write-Host 'We handle the min-size package only when uploading for deb build.'
      Write-Host '- For deb build, the min-size package is moved to a separate folder "finished\minSize",'
      Write-Host '  so that the min-size package can be uploaded to a different Az Blob container.'
      Write-Host '- For other builds, the min-size package is removed after being downloaded, so that it'
      Write-Host '  does not get accidentally uploaded to the wrong Az Blob container.'
      $minSizePkg = '$(System.ArtifactsDirectory)\finished\release\*-gc.tar.gz'
      if (Test-Path -Path $minSizePkg)
      {
          if ('$(buildName)' -eq 'DEB')
          {
              $minSizeDir = '$(System.ArtifactsDirectory)\finished\minSize'
              New-Item -Path $minSizeDir -Type Directory -Force > $null
              Move-Item -Path $minSizePkg -Destination $minSizeDir
              Write-Host "`nCapture the min-size package moved to the target folder."
              Get-ChildItem -Path $minSizeDir
          }
          else
          {
              Write-Host '$(buildName): Remove the min-size package.'
              Remove-Item -Path $minSizePkg -Force
          }
      }
      else
      {
          Write-Host 'min-size package not found, so skip this step.'
      }
    displayName: 'Move minSize package to separate folder'
  - task: DownloadBuildArtifacts@0
    displayName: 'Download rpm Artifacts copy'
    inputs:
      downloadType: specific
      itemPattern: '**/*.rpm'
      downloadPath: '$(System.ArtifactsDirectory)\rpm'
    condition: and(eq(variables['buildName'], 'RPM'), succeeded())
  - template: EsrpScan.yml@ComplianceRepo
    parameters:
      scanPath: $(System.ArtifactsDirectory)
      pattern: |
        **\*.rpm
        **\*.deb
        **\*.tar.gz
  - ${{ if eq(variables['buildName'], 'RPM') }}:
    - template: EsrpSign.yml@ComplianceRepo
      parameters:
        buildOutputPath: $(System.ArtifactsDirectory)\rpm
        signOutputPath: $(Build.StagingDirectory)\signedPackages
        certificateId: "CP-450779-Pgp"
        pattern: |
          **\*.rh.*.rpm
        useMinimatch: true
        shouldSign: $(SHOULD_SIGN)
        displayName: Sign RedHat RPM
        OutputMode: AlwaysCopy
  - ${{ if eq(variables['buildName'], 'RPM') }}:
    - template: EsrpSign.yml@ComplianceRepo
      parameters:
        buildOutputPath: $(Build.StagingDirectory)\signedPackages
        signOutputPath: $(Build.StagingDirectory)\signedPackages
        certificateId: "CP-459159-Pgp"
        pattern: |
          **\*.cm.*.rpm
          **\*.cm?.*.rpm
        useMinimatch: true
        shouldSign: $(SHOULD_SIGN)
        displayName: Sign Mariner RPM
        OutputMode: NeverCopy
  - ${{ if ne(variables['buildName'], 'RPM') }}:
    - task: AzureFileCopy@4
      displayName: 'Upload to Azure - DEB and tar.gz'
      inputs:
        SourcePath: '$(System.ArtifactsDirectory)\finished\release\*'
        azureSubscription: az-blob-cicd-infra
        Destination: AzureBlob
        storage: '$(StorageAccount)'
        ContainerName: '$(AzureVersion)'
      retryCountOnTaskFailure: 2
  - template: /.pipelines/templates/upload-final-results.yml@self
    parameters:
      artifactPath: $(System.ArtifactsDirectory)\finished\release
  - task: AzureFileCopy@4
    displayName: 'Upload to Azure - min-size package for Guest Config'
    inputs:
      SourcePath: '$(System.ArtifactsDirectory)\finished\minSize\*'
      azureSubscription: az-blob-cicd-infra
      Destination: AzureBlob
      storage: '$(StorageAccount)'
      ContainerName: '$(AzureVersion)-gc'
    condition: and(eq(variables['buildName'], 'DEB'), succeeded())
    retryCountOnTaskFailure: 2
  - template: /.pipelines/templates/upload-final-results.yml@self
    parameters:
      artifactPath: $(System.ArtifactsDirectory)\finished\minSize
      condition: and(eq(variables['buildName'], 'DEB'), succeeded())
  - task: AzureFileCopy@4
    displayName: 'Upload to Azure - RPM - Unsigned'
    inputs:
      SourcePath: '$(System.ArtifactsDirectory)\rpm\release\*'
      azureSubscription: az-blob-cicd-infra
      Destination: AzureBlob
      storage: '$(StorageAccount)'
      ContainerName: '$(AzureVersion)'
    condition: and(and(succeeded(), ne(variables['SHOULD_SIGN'], 'true')),eq(variables['buildName'], 'RPM'))
    retryCountOnTaskFailure: 2
  - task: AzureFileCopy@4
    displayName: 'Upload to Azure - RPM - Signed'
    inputs:
      SourcePath: '$(Build.StagingDirectory)\signedPackages\release\*'
      azureSubscription: az-blob-cicd-infra
      Destination: AzureBlob
      storage: '$(StorageAccount)'
      ContainerName: '$(AzureVersion)'
    condition: and(and(succeeded(), eq(variables['SHOULD_SIGN'], 'true')),eq(variables['buildName'], 'RPM'))
    retryCountOnTaskFailure: 2
  - template: /.pipelines/templates/upload-final-results.yml@self
    parameters:
      artifactPath: $(System.ArtifactsDirectory)\rpm\release
      condition: and(and(succeeded(), ne(variables['SHOULD_SIGN'], 'true')),eq(variables['buildName'], 'RPM'))
  - template: /.pipelines/templates/upload-final-results.yml@self
    parameters:
      artifactPath: '$(Build.StagingDirectory)\signedPackages\release'
      condition: and(and(succeeded(), eq(variables['SHOULD_SIGN'], 'true')),eq(variables['buildName'], 'RPM'))
  - template: /.pipelines/templates/step/finalize.yml@self
